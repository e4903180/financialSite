{"ast":null,"code":"import * as React from 'react';\nimport { Options, tokenize } from 'linkifyjs';\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n/**\n * Given a string, converts to an array of valid React components\n * (which may include strings)\n * @param {string} str\n * @param {any} opts\n * @returns {React.ReactNodeArray}\n */\n\n\nfunction stringToElements(str, opts) {\n  var tokens = tokenize(str);\n  var elements = [];\n  var linkId = 0;\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (token.t === 'nl' && opts.nl2br) {\n      elements.push(React.createElement('br', {\n        key: \"linkified-\".concat(++linkId)\n      }));\n      continue;\n    } else if (!token.isLink || !opts.check(token)) {\n      // Regular text\n      elements.push(token.toString());\n      continue;\n    }\n\n    var _opts$resolve = opts.resolve(token),\n        formatted = _opts$resolve.formatted,\n        formattedHref = _opts$resolve.formattedHref,\n        tagName = _opts$resolve.tagName,\n        className = _opts$resolve.className,\n        target = _opts$resolve.target,\n        rel = _opts$resolve.rel,\n        attributes = _opts$resolve.attributes;\n\n    var props = {\n      key: \"linkified-\".concat(++linkId),\n      href: formattedHref\n    };\n\n    if (className) {\n      props.className = className;\n    }\n\n    if (target) {\n      props.target = target;\n    }\n\n    if (rel) {\n      props.rel = rel;\n    } // Build up additional attributes\n    // Support for events via attributes hash\n\n\n    if (attributes) {\n      for (var attr in attributes) {\n        props[attr] = attributes[attr];\n      }\n    }\n\n    elements.push(React.createElement(tagName, props, formatted));\n  }\n\n  return elements;\n} // Recursively linkify the contents of the given React Element instance\n\n/**\n * @template P\n * @template {string | React.JSXElementConstructor<P>} T\n * @param {React.ReactElement<P, T>} element\n * @param {Object} opts\n * @param {number} elementId\n * @returns {React.ReactElement<P, T>}\n */\n\n\nfunction linkifyReactElement(element, opts) {\n  var elementId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  if (React.Children.count(element.props.children) === 0) {\n    // No need to clone if the element had no children\n    return element;\n  }\n\n  var children = [];\n  React.Children.forEach(element.props.children, function (child) {\n    if (typeof child === 'string') {\n      // ensure that we always generate unique element IDs for keys\n      elementId = elementId + 1;\n      children.push.apply(children, _toConsumableArray(stringToElements(child, opts)));\n    } else if (React.isValidElement(child)) {\n      if (typeof child.type === 'string' && opts.ignoreTags.indexOf(child.type.toUpperCase()) >= 0) {\n        // Don't linkify this element\n        children.push(child);\n      } else {\n        children.push(linkifyReactElement(child, opts, ++elementId));\n      }\n    } else {\n      // Unknown element type, just push\n      children.push(child);\n    }\n  }); // Set a default unique key, copy over remaining props\n\n  var newProps = {\n    key: \"linkified-element-\".concat(elementId)\n  };\n\n  for (var prop in element.props) {\n    newProps[prop] = element.props[prop];\n  }\n\n  return React.cloneElement(element, newProps, children);\n}\n/**\n * @template P\n * @template {string | React.JSXElementConstructor<P>} T\n * @param {P & { tagName?: T, options?: any, children?: React.ReactNode}} props\n * @returns {React.ReactElement<P, T>}\n */\n\n\nvar Linkify = function Linkify(props) {\n  // Copy over all non-linkify-specific props\n  var newProps = {\n    key: 'linkified-element-wrapper'\n  };\n\n  for (var prop in props) {\n    if (prop !== 'options' && prop !== 'tagName' && prop !== 'children') {\n      newProps[prop] = props[prop];\n    }\n  }\n\n  var opts = new Options(props.options);\n  var tagName = props.tagName || React.Fragment || 'span';\n  var children = props.children;\n  var element = React.createElement(tagName, newProps, children);\n  return linkifyReactElement(element, opts, 0);\n};\n\nexport { Linkify as default };","map":null,"metadata":{},"sourceType":"module"}