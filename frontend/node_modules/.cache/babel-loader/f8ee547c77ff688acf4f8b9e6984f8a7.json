{"ast":null,"code":"/*\n Highstock JS v10.2.1 (2022-08-29)\n\n Highcharts Stock as a plugin for Highcharts\n\n (c) 2010-2021 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (a) {\n  \"object\" === typeof module && module.exports ? (a[\"default\"] = a, module.exports = a) : \"function\" === typeof define && define.amd ? define(\"highcharts/modules/stock\", [\"highcharts\"], function (J) {\n    a(J);\n    a.Highcharts = J;\n    return a;\n  }) : a(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (a) {\n  function J(a, v, A, l) {\n    a.hasOwnProperty(v) || (a[v] = l.apply(null, A), \"function\" === typeof CustomEvent && window.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: v,\n        module: a[v]\n      }\n    })));\n  }\n\n  a = a ? a._modules : {};\n  J(a, \"Core/Axis/OrdinalAxis.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Utilities.js\"]], function (a, v, A, l) {\n    var y = l.addEvent,\n        r = l.correctFloat,\n        D = l.css,\n        t = l.defined,\n        b = l.error,\n        m = l.pick,\n        d = l.timeUnits,\n        C = [],\n        k;\n\n    (function (k) {\n      function E(f, e, c, p, n, h, u) {\n        void 0 === n && (n = []);\n        void 0 === h && (h = 0);\n        var w = {},\n            P = this.options.tickPixelInterval,\n            Q = this.chart.time,\n            B = [],\n            G,\n            z,\n            g = 0,\n            x = [],\n            k = -Number.MAX_VALUE;\n        if (!this.options.ordinal && !this.options.breaks || !n || 3 > n.length || \"undefined\" === typeof e) return Q.getTimeTicks.apply(Q, arguments);\n        var m = n.length;\n\n        for (G = 0; G < m; G++) {\n          var F = G && n[G - 1] > c;\n          n[G] < e && (g = G);\n\n          if (G === m - 1 || n[G + 1] - n[G] > 5 * h || F) {\n            if (n[G] > k) {\n              for (z = Q.getTimeTicks(f, n[g], n[G], p); z.length && z[0] <= k;) {\n                z.shift();\n              }\n\n              z.length && (k = z[z.length - 1]);\n              B.push(x.length);\n              x = x.concat(z);\n            }\n\n            g = G + 1;\n          }\n\n          if (F) break;\n        }\n\n        if (z) {\n          z = z.info;\n\n          if (u && z.unitRange <= d.hour) {\n            G = x.length - 1;\n\n            for (g = 1; g < G; g++) {\n              if (Q.dateFormat(\"%d\", x[g]) !== Q.dateFormat(\"%d\", x[g - 1])) {\n                w[x[g]] = \"day\";\n                var q = !0;\n              }\n            }\n\n            q && (w[x[0]] = \"day\");\n            z.higherRanks = w;\n          }\n\n          z.segmentStarts = B;\n          x.info = z;\n        } else b(12, !1, this.chart);\n\n        if (u && t(P)) {\n          z = x.length;\n          Q = [];\n          g = [];\n          G = void 0;\n\n          for (q = z; q--;) {\n            B = this.translate(x[q]), G && (g[q] = G - B), Q[q] = G = B;\n          }\n\n          g.sort();\n          g = g[Math.floor(g.length / 2)];\n          g < .6 * P && (g = null);\n          q = x[z - 1] > c ? z - 1 : z;\n\n          for (G = void 0; q--;) {\n            B = Q[q], z = Math.abs(G - B), G && z < .8 * P && (null === g || z < .8 * g) ? (w[x[q]] && !w[x[q + 1]] ? (z = q + 1, G = B) : z = q, x.splice(z, 1)) : G = B;\n          }\n        }\n\n        return x;\n      }\n\n      function L(f) {\n        var e = this.ordinal.positions;\n        if (!e) return f;\n        var c = e.length - 1;\n        if (0 > f) f = e[0];else if (f > c) f = e[c];else {\n          c = Math.floor(f);\n          var p = f - c;\n        }\n        return \"undefined\" !== typeof p && \"undefined\" !== typeof e[c] ? e[c] + (p ? p * (e[c + 1] - e[c]) : 0) : f;\n      }\n\n      function K(f) {\n        var e = this.ordinal,\n            c = e.positions;\n        if (!c) return f;\n        var p = (f - (this.old ? this.old.min : this.min)) * (this.old ? this.old.transA : this.transA) + this.minPixelPadding;\n        0 < p && p < this.left + this.len || (e.extendedOrdinalPositions || (e.extendedOrdinalPositions = e.getExtendedPositions()), c = e.extendedOrdinalPositions);\n\n        if (c && c.length) {\n          f = e.getIndexOfPoint(p, c);\n          e = r(f % 1);\n          if (0 <= f && f < c.length - 1) return c[Math.floor(f)] + e * (c[Math.ceil(f)] - c[Math.floor(f)]);\n          e = c.length;\n          p = c[0];\n          c = c[e - 1];\n          var n = (c - p) / (e - 1);\n          return 0 > f ? p + n * f : c + n * (f - e);\n        }\n\n        return f;\n      }\n\n      function q(f, e) {\n        var c = k.Additions.findIndexOf(f, e, !0);\n        return f[c] === e ? c : c + (e - f[c]) / (f[c + 1] - f[c]);\n      }\n\n      function a() {\n        this.ordinal || (this.ordinal = new k.Additions(this));\n      }\n\n      function l() {\n        this.isXAxis && t(this.options.overscroll) && this.max === this.dataMax && (!this.chart.mouseIsDown || this.isInternal) && (!this.eventArgs || this.eventArgs && \"navigator\" !== this.eventArgs.trigger) && (this.max += this.options.overscroll, !this.isInternal && t(this.userMin) && (this.min += this.options.overscroll));\n      }\n\n      function F() {\n        this.horiz && !this.isDirty && (this.isDirty = this.isOrdinal && this.chart.navigator && !this.chart.navigator.adaptToUpdatedData);\n      }\n\n      function M() {\n        this.ordinal && (this.ordinal.beforeSetTickPositions(), this.tickInterval = this.ordinal.postProcessTickInterval(this.tickInterval));\n      }\n\n      function g(f) {\n        var e = this.xAxis[0],\n            c = e.options.overscroll,\n            p = f.originalEvent.chartX,\n            n = this.options.chart.panning,\n            h = !1;\n\n        if (n && \"y\" !== n.type && e.options.ordinal && e.series.length) {\n          var u = this.mouseDownX,\n              w = e.getExtremes(),\n              P = w.dataMax,\n              Q = w.min,\n              B = w.max,\n              G = this.hoverPoints,\n              z = e.closestPointRange || e.ordinal && e.ordinal.overscrollPointsRange;\n          u = (u - p) / (e.translationSlope * (e.ordinal.slope || z));\n          z = e.ordinal.getExtendedPositions();\n          z = {\n            ordinal: {\n              positions: z,\n              extendedOrdinalPositions: z\n            }\n          };\n          var g = e.index2val,\n              x = e.val2lin,\n              d = void 0,\n              q = d = void 0,\n              k = void 0;\n          z.ordinal.positions ? 1 < Math.abs(u) && (G && G.forEach(function (h) {\n            h.setState();\n          }), 0 > u ? (q = z, k = e.ordinal.positions ? e : z) : (q = e.ordinal.positions ? e : z, k = z), d = k.ordinal.positions, P > d[d.length - 1] && d.push(P), this.fixedRange = B - Q, d = e.navigatorAxis.toFixedRange(void 0, void 0, g.apply(q, [x.apply(q, [Q, !0]) + u]), g.apply(k, [x.apply(k, [B, !0]) + u])), d.min >= Math.min(w.dataMin, Q) && d.max <= Math.max(P, B) + c && e.setExtremes(d.min, d.max, !0, !1, {\n            trigger: \"pan\"\n          }), this.mouseDownX = p, D(this.container, {\n            cursor: \"move\"\n          })) : h = !0;\n        } else h = !0;\n\n        h || n && /y/.test(n.type) ? c && (e.max = e.dataMax + c) : f.preventDefault();\n      }\n\n      function O() {\n        var f = this.xAxis;\n        f && f.options.ordinal && (delete f.ordinal.index, delete f.ordinal.extendedOrdinalPositions);\n      }\n\n      function x(f, e) {\n        var c = this.ordinal,\n            p = c.positions,\n            n = c.slope,\n            h = c.extendedOrdinalPositions;\n        if (!p) return f;\n        var u = p.length;\n        if (p[0] <= f && p[u - 1] >= f) f = q(p, f);else {\n          h || (h = c.getExtendedPositions && c.getExtendedPositions(), c.extendedOrdinalPositions = h);\n          if (!h || !h.length) return f;\n          u = h.length;\n          n || (n = (h[u - 1] - h[0]) / u);\n          p = q(h, p[0]);\n          f >= h[0] && f <= h[u - 1] ? f = q(h, f) - p : f < h[0] ? (f = h[0] - f, f = -p - f / n) : (f -= h[u - 1], f = f / n + u - p);\n        }\n        return e ? f : n * (f || 0) + c.offset;\n      }\n\n      k.compose = function (f, e, c) {\n        if (-1 === C.indexOf(f)) {\n          C.push(f);\n          var p = f.prototype;\n          p.getTimeTicks = E;\n          p.index2val = L;\n          p.lin2val = K;\n          p.val2lin = x;\n          p.ordinal2lin = p.val2lin;\n          y(f, \"afterInit\", a);\n          y(f, \"foundExtremes\", l);\n          y(f, \"afterSetScale\", F);\n          y(f, \"initialAxisTranslation\", M);\n        }\n\n        -1 === C.indexOf(c) && (C.push(c), y(c, \"pan\", g));\n        -1 === C.indexOf(e) && (C.push(e), y(e, \"updatedData\", O));\n        return f;\n      };\n\n      var I = function () {\n        function f(e) {\n          this.index = {};\n          this.axis = e;\n        }\n\n        f.prototype.beforeSetTickPositions = function () {\n          var e = this.axis,\n              c = e.ordinal,\n              p = e.getExtremes(),\n              n = p.min,\n              h = p.max,\n              u = e.isXAxis && !!e.options.breaks;\n          p = e.options.ordinal;\n          var w = e.chart.options.chart.ignoreHiddenSeries,\n              f,\n              g,\n              B = [],\n              G = Number.MAX_VALUE,\n              z = !1,\n              x = !1,\n              d = !1;\n\n          if (p || u) {\n            var k = 0;\n            e.series.forEach(function (h, c) {\n              f = [];\n              0 < c && \"highcharts-navigator-series\" !== h.options.id && (x = k !== h.processedXData[1] - h.processedXData[0]);\n              k = h.processedXData[1] - h.processedXData[0];\n              h.boosted && (d = h.boosted);\n\n              if (!(w && !1 === h.visible || !1 === h.takeOrdinalPosition && !u) && (B = B.concat(h.processedXData), q = B.length, B.sort(function (h, c) {\n                return h - c;\n              }), G = Math.min(G, m(h.closestPointRange, G)), q)) {\n                for (c = 0; c < q - 1;) {\n                  B[c] !== B[c + 1] && f.push(B[c + 1]), c++;\n                }\n\n                f[0] !== B[0] && f.unshift(B[0]);\n                B = f;\n              }\n            });\n            x && d && (B.pop(), B.shift());\n            var q = B.length;\n\n            if (2 < q) {\n              var b = B[1] - B[0];\n\n              for (g = q - 1; g-- && !z;) {\n                B[g + 1] - B[g] !== b && (z = !0);\n              }\n\n              !e.options.keepOrdinalPadding && (B[0] - n > b || h - B[B.length - 1] > b) && (z = !0);\n            } else e.options.overscroll && (2 === q ? G = B[1] - B[0] : 1 === q ? (G = e.options.overscroll, B = [B[0], B[0] + G]) : G = c.overscrollPointsRange);\n\n            z || e.forceOrdinal ? (e.options.overscroll && (c.overscrollPointsRange = G, B = B.concat(c.getOverscrollPositions())), c.positions = B, b = e.ordinal2lin(Math.max(n, B[0]), !0), g = Math.max(e.ordinal2lin(Math.min(h, B[B.length - 1]), !0), 1), c.slope = h = (h - n) / (g - b), c.offset = n - b * h) : (c.overscrollPointsRange = m(e.closestPointRange, c.overscrollPointsRange), c.positions = e.ordinal.slope = c.offset = void 0);\n          }\n\n          e.isOrdinal = p && z;\n          c.groupIntervalFactor = null;\n        };\n\n        f.findIndexOf = function (e, c, p) {\n          for (var n = 0, h = e.length - 1, u; n < h;) {\n            u = Math.ceil((n + h) / 2), e[u] <= c ? n = u : h = u - 1;\n          }\n\n          return e[n] === c ? n : p ? n : -1;\n        };\n\n        f.prototype.getExtendedPositions = function () {\n          var e = this,\n              c = e.axis,\n              p = c.constructor.prototype,\n              n = c.chart,\n              h = c.series[0].currentDataGrouping,\n              u = h ? h.count + h.unitName : \"raw\",\n              w = c.options.overscroll,\n              f = c.getExtremes(),\n              g = void 0,\n              B = e.index;\n          B || (B = e.index = {});\n\n          if (!B[u]) {\n            var G = {\n              series: [],\n              chart: n,\n              forceOrdinal: !1,\n              getExtremes: function getExtremes() {\n                return {\n                  min: f.dataMin,\n                  max: f.dataMax + w\n                };\n              },\n              getGroupPixelWidth: p.getGroupPixelWidth,\n              getTimeTicks: p.getTimeTicks,\n              options: {\n                ordinal: !0\n              },\n              ordinal: {\n                getGroupIntervalFactor: this.getGroupIntervalFactor\n              },\n              ordinal2lin: p.ordinal2lin,\n              getIndexOfPoint: p.getIndexOfPoint,\n              val2lin: p.val2lin\n            };\n            G.ordinal.axis = G;\n            c.series.forEach(function (c) {\n              g = {\n                xAxis: G,\n                xData: c.xData.slice(),\n                chart: n,\n                destroyGroupedData: v.noop,\n                getProcessedData: A.prototype.getProcessedData,\n                applyGrouping: A.prototype.applyGrouping\n              };\n              g.xData = g.xData.concat(e.getOverscrollPositions());\n              g.options = {\n                dataGrouping: h ? {\n                  firstAnchor: \"firstPoint\",\n                  anchor: \"middle\",\n                  lastAnchor: \"lastPoint\",\n                  enabled: !0,\n                  forced: !0,\n                  approximation: \"open\",\n                  units: [[h.unitName, [h.count]]]\n                } : {\n                  enabled: !1\n                }\n              };\n              G.series.push(g);\n              c.processData.apply(g);\n            });\n            g.closestPointRange !== g.basePointRange && g.currentDataGrouping && (G.forceOrdinal = !0);\n            c.ordinal.beforeSetTickPositions.apply({\n              axis: G\n            });\n            B[u] = G.ordinal.positions;\n          }\n\n          return B[u];\n        };\n\n        f.prototype.getGroupIntervalFactor = function (e, c, p) {\n          p = p.processedXData;\n          var n = p.length,\n              h = [];\n          var u = this.groupIntervalFactor;\n\n          if (!u) {\n            for (u = 0; u < n - 1; u++) {\n              h[u] = p[u + 1] - p[u];\n            }\n\n            h.sort(function (h, c) {\n              return h - c;\n            });\n            h = h[Math.floor(n / 2)];\n            e = Math.max(e, p[0]);\n            c = Math.min(c, p[n - 1]);\n            this.groupIntervalFactor = u = n * h / (c - e);\n          }\n\n          return u;\n        };\n\n        f.prototype.getIndexOfPoint = function (e, c) {\n          var p = this.axis,\n              n = this.positions ? this.positions[0] : 0,\n              h = p.series[0].points && p.series[0].points[0] && p.series[0].points[0].plotX || p.minPixelPadding;\n          1 < p.series.length && p.series.forEach(function (c) {\n            c.points && t(c.points[0]) && t(c.points[0].plotX) && c.points[0].plotX < h && (h = c.points[0].plotX);\n          });\n          e = (e - h) / (p.translationSlope * (this.slope || p.closestPointRange || this.overscrollPointsRange));\n          return f.findIndexOf(c, n) + e;\n        };\n\n        f.prototype.getOverscrollPositions = function () {\n          var e = this.axis,\n              c = e.options.overscroll,\n              p = this.overscrollPointsRange,\n              n = [],\n              h = e.dataMax;\n          if (t(p)) for (; h <= e.dataMax + c;) {\n            h += p, n.push(h);\n          }\n          return n;\n        };\n\n        f.prototype.postProcessTickInterval = function (e) {\n          var c = this.axis,\n              p = this.slope;\n          return p ? c.options.breaks ? c.closestPointRange || e : e / (p / c.closestPointRange) : e;\n        };\n\n        return f;\n      }();\n\n      k.Additions = I;\n    })(k || (k = {}));\n\n    return k;\n  });\n  J(a, \"Series/DataModifyComposition.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Utilities.js\"]], function (a, v, A, l) {\n    var y = v.prototype.tooltipFormatter,\n        r = l.addEvent,\n        D = l.arrayMax,\n        t = l.arrayMin,\n        b = l.correctFloat,\n        m = l.defined,\n        d = l.isArray,\n        C = l.isNumber,\n        k = l.isString,\n        K = l.pick,\n        E;\n\n    (function (L) {\n      function a(e, c, p) {\n        this.isXAxis || (this.series.forEach(function (n) {\n          \"compare\" === e && \"boolean\" !== typeof c ? n.setCompare(c, !1) : \"cumulative\" !== e || k(c) || n.setCumulative(c, !1);\n        }), K(p, !0) && this.chart.redraw());\n      }\n\n      function q(e) {\n        var c = this,\n            p = c.series.chart.numberFormatter,\n            n = function n(h) {\n          e = e.replace(\"{point.\" + h + \"}\", (0 < c[h] && \"change\" === h ? \"+\" : \"\") + p(c[h], K(c.series.tooltipOptions.changeDecimals, 2)));\n        };\n\n        m(c.change) && n(\"change\");\n        m(c.cumulativeSum) && n(\"cumulativeSum\");\n        return y.apply(this, [e]);\n      }\n\n      function E() {\n        var e = this.options.compare;\n\n        if (\"percent\" === e || \"value\" === e || this.options.cumulative) {\n          var c = new f(this);\n          \"percent\" === e || \"value\" === e ? c.initCompare(e) : c.initCumulative();\n        }\n\n        this.dataModify = c;\n      }\n\n      function l(e) {\n        e = e.dataExtremes;\n        var c = e.activeYData;\n\n        if (this.dataModify && e) {\n          var p = void 0;\n          this.options.compare ? p = [this.dataModify.modifyValue(e.dataMin), this.dataModify.modifyValue(e.dataMax)] : this.options.cumulative && d(c) && 2 <= c.length && (p = f.getCumulativeExtremes(c));\n          p && (e.dataMin = t(p), e.dataMax = D(p));\n        }\n      }\n\n      function F(e, c) {\n        this.options.compare = this.userOptions.compare = e;\n        this.update({}, K(c, !0));\n        !this.dataModify || \"value\" !== e && \"percent\" !== e ? this.points.forEach(function (c) {\n          delete c.change;\n        }) : this.dataModify.initCompare(e);\n      }\n\n      function M() {\n        if (this.xAxis && this.processedYData && this.dataModify) {\n          var e = this.processedXData,\n              c = this.processedYData,\n              p = c.length,\n              n = !0 === this.options.compareStart ? 0 : 1,\n              h = -1,\n              u;\n          this.pointArrayMap && (h = this.pointArrayMap.indexOf(this.options.pointValKey || this.pointValKey || \"y\"));\n\n          for (u = 0; u < p - n; u++) {\n            var w = c[u] && -1 < h ? c[u][h] : c[u];\n\n            if (C(w) && 0 !== w && e[u + n] >= (this.xAxis.min || 0)) {\n              this.dataModify.compareValue = w;\n              break;\n            }\n          }\n        }\n      }\n\n      function g(e, c) {\n        this.setModifier(\"compare\", e, c);\n      }\n\n      function O(e, c) {\n        e = K(e, !1);\n        this.options.cumulative = this.userOptions.cumulative = e;\n        this.update({}, K(c, !0));\n        this.dataModify ? this.dataModify.initCumulative() : this.points.forEach(function (c) {\n          delete c.cumulativeSum;\n        });\n      }\n\n      function x(e, c) {\n        this.setModifier(\"cumulative\", e, c);\n      }\n\n      var I = [];\n\n      L.compose = function (e, c, p) {\n        if (-1 === I.indexOf(e)) {\n          I.push(e);\n          var n = e.prototype;\n          n.setCompare = F;\n          n.setCumulative = O;\n          r(e, \"afterInit\", E);\n          r(e, \"afterGetExtremes\", l);\n          r(e, \"afterProcessData\", M);\n        }\n\n        -1 === I.indexOf(c) && (I.push(c), c = c.prototype, c.setCompare = g, c.setModifier = a, c.setCumulative = x);\n        -1 === I.indexOf(p) && (I.push(p), p.prototype.tooltipFormatter = q);\n        return e;\n      };\n\n      var f = function () {\n        function e(c) {\n          this.series = c;\n        }\n\n        e.prototype.modifyValue = function () {\n          return 0;\n        };\n\n        e.getCumulativeExtremes = function (c) {\n          var e = Infinity,\n              n = -Infinity;\n          c.reduce(function (h, c) {\n            c = h + c;\n            e = Math.min(e, c, h);\n            n = Math.max(n, c, h);\n            return c;\n          });\n          return [e, n];\n        };\n\n        e.prototype.initCompare = function (c) {\n          this.modifyValue = function (e, n) {\n            null === e && (e = 0);\n            var h = this.compareValue;\n            return \"undefined\" !== typeof e && \"undefined\" !== typeof h ? (e = \"value\" === c ? e - h : e / h * 100 - (100 === this.series.options.compareBase ? 0 : 100), \"undefined\" !== typeof n && (n = this.series.points[n]) && (n.change = e), e) : 0;\n          };\n        };\n\n        e.prototype.initCumulative = function () {\n          this.modifyValue = function (c, e) {\n            null === c && (c = 0);\n\n            if (void 0 !== c && void 0 !== e) {\n              var n = 0 < e ? this.series.points[e - 1] : null;\n              n && n.cumulativeSum && (c = b(n.cumulativeSum + c));\n              if (e = this.series.points[e]) e.cumulativeSum = c;\n              return c;\n            }\n\n            return 0;\n          };\n        };\n\n        return e;\n      }();\n\n      L.Additions = f;\n    })(E || (E = {}));\n\n    \"\";\n    return E;\n  });\n  J(a, \"Core/Axis/BrokenAxis.js\", [a[\"Core/Axis/Stacking/StackItem.js\"], a[\"Core/Utilities.js\"]], function (a, v) {\n    var A = v.addEvent,\n        l = v.find,\n        y = v.fireEvent,\n        r = v.isArray,\n        D = v.isNumber,\n        t = v.pick,\n        b;\n\n    (function (b) {\n      function d() {\n        \"undefined\" !== typeof this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);\n      }\n\n      function m() {\n        this.brokenAxis && this.brokenAxis.hasBreaks && (this.options.ordinal = !1);\n      }\n\n      function k() {\n        var d = this.brokenAxis;\n\n        if (d && d.hasBreaks) {\n          for (var q = this.tickPositions, g = this.tickPositions.info, k = [], x = 0; x < q.length; x++) {\n            d.isInAnyBreak(q[x]) || k.push(q[x]);\n          }\n\n          this.tickPositions = k;\n          this.tickPositions.info = g;\n        }\n      }\n\n      function K() {\n        this.brokenAxis || (this.brokenAxis = new N(this));\n      }\n\n      function E() {\n        var d = this.options.connectNulls,\n            q = this.points,\n            g = this.xAxis,\n            k = this.yAxis;\n        if (this.isDirty) for (var x = q.length; x--;) {\n          var b = q[x],\n              f = !(null === b.y && !1 === d) && (g && g.brokenAxis && g.brokenAxis.isInAnyBreak(b.x, !0) || k && k.brokenAxis && k.brokenAxis.isInAnyBreak(b.y, !0));\n          b.visible = f ? !1 : !1 !== b.options.visible;\n        }\n      }\n\n      function L() {\n        this.drawBreaks(this.xAxis, [\"x\"]);\n        this.drawBreaks(this.yAxis, t(this.pointArrayMap, [\"y\"]));\n      }\n\n      function H(d, q) {\n        var g = this,\n            k = g.points,\n            x,\n            b,\n            f,\n            e;\n\n        if (d && d.brokenAxis && d.brokenAxis.hasBreaks) {\n          var c = d.brokenAxis;\n          q.forEach(function (p) {\n            x = c && c.breakArray || [];\n            b = d.isXAxis ? d.min : t(g.options.threshold, d.min);\n            k.forEach(function (c) {\n              e = t(c[\"stack\" + p.toUpperCase()], c[p]);\n              x.forEach(function (h) {\n                if (D(b) && D(e)) {\n                  f = !1;\n                  if (b < h.from && e > h.to || b > h.from && e < h.from) f = \"pointBreak\";else if (b < h.from && e > h.from && e < h.to || b > h.from && e > h.to && e < h.from) f = \"pointInBreak\";\n                  f && y(d, f, {\n                    point: c,\n                    brk: h\n                  });\n                }\n              });\n            });\n          });\n        }\n      }\n\n      function q() {\n        var d = this.currentDataGrouping,\n            q = d && d.gapSize;\n        d = this.points.slice();\n        var g = this.yAxis,\n            b = this.options.gapSize,\n            x = d.length - 1,\n            k;\n        if (b && 0 < x) for (\"value\" !== this.options.gapUnit && (b *= this.basePointRange), q && q > b && q >= this.basePointRange && (b = q), k = void 0; x--;) {\n          k && !1 !== k.visible || (k = d[x + 1]), q = d[x], !1 !== k.visible && !1 !== q.visible && (k.x - q.x > b && (k = (q.x + k.x) / 2, d.splice(x + 1, 0, {\n            isNull: !0,\n            x: k\n          }), g.stacking && this.options.stacking && (k = g.stacking.stacks[this.stackKey][k] = new a(g, g.options.stackLabels, !1, k, this.stack), k.total = 0)), k = q);\n        }\n        return this.getGraphPath(d);\n      }\n\n      var R = [];\n\n      b.compose = function (b, a) {\n        -1 === R.indexOf(b) && (R.push(b), b.keepProps.push(\"brokenAxis\"), A(b, \"init\", K), A(b, \"afterInit\", d), A(b, \"afterSetTickPositions\", k), A(b, \"afterSetOptions\", m));\n\n        if (-1 === R.indexOf(a)) {\n          R.push(a);\n          var g = a.prototype;\n          g.drawBreaks = H;\n          g.gappedPath = q;\n          A(a, \"afterGeneratePoints\", E);\n          A(a, \"afterRender\", L);\n        }\n\n        return b;\n      };\n\n      var N = function () {\n        function d(d) {\n          this.hasBreaks = !1;\n          this.axis = d;\n        }\n\n        d.isInBreak = function (d, g) {\n          var b = d.repeat || Infinity,\n              k = d.from,\n              q = d.to - d.from;\n          g = g >= k ? (g - k) % b : b - (k - g) % b;\n          return d.inclusive ? g <= q : g < q && 0 !== g;\n        };\n\n        d.lin2Val = function (b) {\n          var g = this.brokenAxis;\n          g = g && g.breakArray;\n          if (!g || !D(b)) return b;\n          var k;\n\n          for (k = 0; k < g.length; k++) {\n            var q = g[k];\n            if (q.from >= b) break;else q.to < b ? b += q.len : d.isInBreak(q, b) && (b += q.len);\n          }\n\n          return b;\n        };\n\n        d.val2Lin = function (b) {\n          var g = this.brokenAxis;\n          g = g && g.breakArray;\n          if (!g || !D(b)) return b;\n          var k = b,\n              q;\n\n          for (q = 0; q < g.length; q++) {\n            var m = g[q];\n            if (m.to <= b) k -= m.len;else if (m.from >= b) break;else if (d.isInBreak(m, b)) {\n              k -= b - m.from;\n              break;\n            }\n          }\n\n          return k;\n        };\n\n        d.prototype.findBreakAt = function (d, b) {\n          return l(b, function (b) {\n            return b.from < d && d < b.to;\n          });\n        };\n\n        d.prototype.isInAnyBreak = function (b, g) {\n          var q = this.axis,\n              k = q.options.breaks || [],\n              m = k.length,\n              f;\n\n          if (m && D(b)) {\n            for (; m--;) {\n              if (d.isInBreak(k[m], b)) {\n                var e = !0;\n                f || (f = t(k[m].showPoints, !q.isXAxis));\n              }\n            }\n\n            var c = e && g ? e && !f : e;\n          }\n\n          return c;\n        };\n\n        d.prototype.setBreaks = function (b, k) {\n          var q = this,\n              g = q.axis,\n              m = r(b) && !!b.length;\n          g.isDirty = q.hasBreaks !== m;\n          q.hasBreaks = m;\n          g.options.breaks = g.userOptions.breaks = b;\n          g.forceRedraw = !0;\n          g.series.forEach(function (f) {\n            f.isDirty = !0;\n          });\n          m || g.val2lin !== d.val2Lin || (delete g.val2lin, delete g.lin2val);\n          m && (g.userOptions.ordinal = !1, g.lin2val = d.lin2Val, g.val2lin = d.val2Lin, g.setExtremes = function (f, e, c, p, n) {\n            if (q.hasBreaks) {\n              for (var h = this.options.breaks || [], u; u = q.findBreakAt(f, h);) {\n                f = u.to;\n              }\n\n              for (; u = q.findBreakAt(e, h);) {\n                e = u.from;\n              }\n\n              e < f && (e = f);\n            }\n\n            g.constructor.prototype.setExtremes.call(this, f, e, c, p, n);\n          }, g.setAxisTranslation = function () {\n            g.constructor.prototype.setAxisTranslation.call(this);\n            q.unitLength = void 0;\n\n            if (q.hasBreaks) {\n              var f = g.options.breaks || [],\n                  e = [],\n                  c = [],\n                  p = t(g.pointRangePadding, 0),\n                  n = 0,\n                  h,\n                  u = g.userMin || g.min,\n                  w = g.userMax || g.max,\n                  b;\n              f.forEach(function (c) {\n                h = c.repeat || Infinity;\n                D(u) && D(w) && (d.isInBreak(c, u) && (u += c.to % h - u % h), d.isInBreak(c, w) && (w -= w % h - c.from % h));\n              });\n              f.forEach(function (c) {\n                B = c.from;\n                h = c.repeat || Infinity;\n\n                if (D(u) && D(w)) {\n                  for (; B - h > u;) {\n                    B -= h;\n                  }\n\n                  for (; B < u;) {\n                    B += h;\n                  }\n\n                  for (b = B; b < w; b += h) {\n                    e.push({\n                      value: b,\n                      move: \"in\"\n                    }), e.push({\n                      value: b + c.to - c.from,\n                      move: \"out\",\n                      size: c.breakSize\n                    });\n                  }\n                }\n              });\n              e.sort(function (h, c) {\n                return h.value === c.value ? (\"in\" === h.move ? 0 : 1) - (\"in\" === c.move ? 0 : 1) : h.value - c.value;\n              });\n              var k = 0;\n              var B = u;\n              e.forEach(function (h) {\n                k += \"in\" === h.move ? 1 : -1;\n                1 === k && \"in\" === h.move && (B = h.value);\n                0 === k && D(B) && (c.push({\n                  from: B,\n                  to: h.value,\n                  len: h.value - B - (h.size || 0)\n                }), n += h.value - B - (h.size || 0));\n              });\n              q.breakArray = c;\n              D(u) && D(w) && D(g.min) && (q.unitLength = w - u - n + p, y(g, \"afterBreaks\"), g.staticScale ? g.transA = g.staticScale : q.unitLength && (g.transA *= (w - g.min + p) / q.unitLength), p && (g.minPixelPadding = g.transA * (g.minPointOffset || 0)), g.min = u, g.max = w);\n            }\n          });\n          t(k, !0) && g.chart.redraw();\n        };\n\n        return d;\n      }();\n\n      b.Additions = N;\n    })(b || (b = {}));\n\n    return b;\n  });\n  J(a, \"masters/modules/broken-axis.src.js\", [a[\"Core/Globals.js\"], a[\"Core/Axis/BrokenAxis.js\"]], function (a, v) {\n    v.compose(a.Axis, a.Series);\n  });\n  J(a, \"Extensions/DataGrouping.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Axis/DateTimeAxis.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/Globals.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Tooltip.js\"], a[\"Core/DefaultOptions.js\"], a[\"Core/Utilities.js\"]], function (a, v, A, l, y, r, D, t, b) {\n    var m = A.format,\n        d = r.prototype;\n    A = b.addEvent;\n    var C = b.arrayMax,\n        k = b.arrayMin,\n        K = b.correctFloat,\n        E = b.defined,\n        L = b.error,\n        H = b.extend,\n        q = b.isNumber,\n        R = b.merge,\n        N = b.pick,\n        F = l.approximations = {\n      sum: function sum(f) {\n        var e = f.length;\n        if (!e && f.hasNulls) var c = null;else if (e) for (c = 0; e--;) {\n          c += f[e];\n        }\n        return c;\n      },\n      average: function average(f) {\n        var e = f.length;\n        f = F.sum(f);\n        q(f) && e && (f = K(f / e));\n        return f;\n      },\n      averages: function averages() {\n        var f = [];\n        [].forEach.call(arguments, function (e) {\n          f.push(F.average(e));\n        });\n        return \"undefined\" === typeof f[0] ? void 0 : f;\n      },\n      open: function open(f) {\n        return f.length ? f[0] : f.hasNulls ? null : void 0;\n      },\n      high: function high(f) {\n        return f.length ? C(f) : f.hasNulls ? null : void 0;\n      },\n      low: function low(f) {\n        return f.length ? k(f) : f.hasNulls ? null : void 0;\n      },\n      close: function close(f) {\n        return f.length ? f[f.length - 1] : f.hasNulls ? null : void 0;\n      },\n      hlc: function hlc(f, e, c) {\n        f = F.high(f);\n        e = F.low(e);\n        c = F.close(c);\n        if (q(f) || q(e) || q(c)) return [f, e, c];\n      },\n      ohlc: function ohlc(f, e, c, p) {\n        f = F.open(f);\n        e = F.high(e);\n        c = F.low(c);\n        p = F.close(p);\n        if (q(f) || q(e) || q(c) || q(p)) return [f, e, c, p];\n      },\n      range: function range(f, e) {\n        f = F.low(f);\n        e = F.high(e);\n        if (q(f) || q(e)) return [f, e];\n        if (null === f && null === e) return null;\n      }\n    };\n\n    b = function b(f, e, c, p) {\n      var n = this,\n          h = n.data,\n          u = n.options && n.options.data,\n          w = [],\n          g = [],\n          d = [],\n          b = f.length,\n          k = !!e,\n          z = [],\n          m = n.pointArrayMap,\n          a = m && m.length,\n          L = [\"x\"].concat(m || [\"y\"]),\n          x = this.options.dataGrouping && this.options.dataGrouping.groupAll,\n          K = 0,\n          H = 0,\n          C;\n      p = \"function\" === typeof p ? p : F[p] ? F[p] : F[n.getDGApproximation && n.getDGApproximation() || \"average\"];\n      a ? m.forEach(function () {\n        z.push([]);\n      }) : z.push([]);\n      var y = a || 1;\n\n      for (C = 0; C <= b && !(f[C] >= c[0]); C++) {\n        ;\n      }\n\n      for (C; C <= b; C++) {\n        for (; \"undefined\" !== typeof c[K + 1] && f[C] >= c[K + 1] || C === b;) {\n          var t = c[K];\n          n.dataGroupInfo = {\n            start: x ? H : n.cropStart + H,\n            length: z[0].length\n          };\n          var l = p.apply(n, z);\n          n.pointClass && !E(n.dataGroupInfo.options) && (n.dataGroupInfo.options = R(n.pointClass.prototype.optionsToObject.call({\n            series: n\n          }, n.options.data[n.cropStart + H])), L.forEach(function (h) {\n            delete n.dataGroupInfo.options[h];\n          }));\n          \"undefined\" !== typeof l && (w.push(t), g.push(l), d.push(n.dataGroupInfo));\n          H = C;\n\n          for (t = 0; t < y; t++) {\n            z[t].length = 0, z[t].hasNulls = !1;\n          }\n\n          K += 1;\n          if (C === b) break;\n        }\n\n        if (C === b) break;\n\n        if (m) {\n          t = n.options.dataGrouping && n.options.dataGrouping.groupAll ? C : n.cropStart + C;\n          l = h && h[t] || n.pointClass.prototype.applyOptions.apply({\n            series: n\n          }, [u[t]]);\n          var r = void 0;\n\n          for (t = 0; t < a; t++) {\n            r = l[m[t]], q(r) ? z[t].push(r) : null === r && (z[t].hasNulls = !0);\n          }\n        } else t = k ? e[C] : null, q(t) ? z[0].push(t) : null === t && (z[0].hasNulls = !0);\n      }\n\n      return {\n        groupedXData: w,\n        groupedYData: g,\n        groupMap: d\n      };\n    };\n\n    var M = {\n      approximations: F,\n      groupData: b\n    },\n        g = d.generatePoints,\n        O = {\n      groupPixelWidth: 2,\n      dateTimeLabelFormats: {\n        millisecond: [\"%A, %b %e, %H:%M:%S.%L\", \"%A, %b %e, %H:%M:%S.%L\", \"-%H:%M:%S.%L\"],\n        second: [\"%A, %b %e, %H:%M:%S\", \"%A, %b %e, %H:%M:%S\", \"-%H:%M:%S\"],\n        minute: [\"%A, %b %e, %H:%M\", \"%A, %b %e, %H:%M\", \"-%H:%M\"],\n        hour: [\"%A, %b %e, %H:%M\", \"%A, %b %e, %H:%M\", \"-%H:%M\"],\n        day: [\"%A, %b %e, %Y\", \"%A, %b %e\", \"-%A, %b %e, %Y\"],\n        week: [\"Week from %A, %b %e, %Y\", \"%A, %b %e\", \"-%A, %b %e, %Y\"],\n        month: [\"%B %Y\", \"%B\", \"-%B %Y\"],\n        year: [\"%Y\", \"%Y\", \"-%Y\"]\n      }\n    },\n        x = {\n      line: {},\n      spline: {},\n      area: {},\n      areaspline: {},\n      arearange: {},\n      column: {\n        groupPixelWidth: 10\n      },\n      columnrange: {\n        groupPixelWidth: 10\n      },\n      candlestick: {\n        groupPixelWidth: 10\n      },\n      ohlc: {\n        groupPixelWidth: 5\n      },\n      hlc: {\n        groupPixelWidth: 5\n      },\n      heikinashi: {\n        groupPixelWidth: 10\n      }\n    },\n        I = l.defaultDataGroupingUnits = [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1]], [\"week\", [1]], [\"month\", [1, 3, 6]], [\"year\", null]];\n\n    d.getDGApproximation = function () {\n      return this.is(\"arearange\") ? \"range\" : this.is(\"ohlc\") ? \"ohlc\" : this.is(\"hlc\") ? \"hlc\" : this.is(\"column\") ? \"sum\" : \"average\";\n    };\n\n    d.groupData = b;\n\n    d.applyGrouping = function (f) {\n      var e = this.chart,\n          c = this.options.dataGrouping,\n          p = !1 !== this.allowDG && c && N(c.enabled, e.options.isStock),\n          n = this.visible || !e.options.chart.ignoreHiddenSeries,\n          h,\n          u = this.currentDataGrouping,\n          w = !1;\n      p && !this.requireSorting && (this.requireSorting = w = !0);\n      f = !1 === !(this.isCartesian && !this.isDirty && !this.xAxis.isDirty && !this.yAxis.isDirty && !f) || !p;\n      w && (this.requireSorting = !1);\n\n      if (!f) {\n        this.destroyGroupedData();\n        p = c.groupAll ? this.xData : this.processedXData;\n        var g = c.groupAll ? this.yData : this.processedYData;\n        f = e.plotSizeX;\n        w = this.xAxis;\n        var b = w.options.ordinal,\n            B = this.groupPixelWidth;\n\n        if (B && p && p.length) {\n          this.isDirty = h = !0;\n          this.points = null;\n          var k = w.getExtremes();\n          var z = k.min;\n          k = k.max;\n          b = b && w.ordinal && w.ordinal.getGroupIntervalFactor(z, k, this) || 1;\n          f = w.getTimeTicks(v.Additions.prototype.normalizeTimeTickInterval(B * (k - z) / f * b, c.units || I), Math.min(z, p[0]), Math.max(k, p[p.length - 1]), w.options.startOfWeek, p, this.closestPointRange);\n          B = d.groupData.apply(this, [p, g, f, c.approximation]);\n          p = B.groupedXData;\n          g = B.groupedYData;\n          b = 0;\n          c && c.smoothed && p.length && (c.firstAnchor = \"firstPoint\", c.anchor = \"middle\", c.lastAnchor = \"lastPoint\", L(32, !1, e, {\n            \"dataGrouping.smoothed\": \"use dataGrouping.anchor\"\n          }));\n          e = p;\n          var m = this.options.dataGrouping;\n          z = this.currentDataGrouping && this.currentDataGrouping.gapSize;\n\n          if (m && this.xData && z && this.groupMap) {\n            var a = e.length - 1;\n            var x = m.anchor;\n            var K = N(m.firstAnchor, x);\n            m = N(m.lastAnchor, x);\n\n            if (x && \"start\" !== x) {\n              var C = z * {\n                middle: .5,\n                end: 1\n              }[x];\n\n              for (x = e.length - 1; x-- && 0 < x;) {\n                e[x] += C;\n              }\n            }\n\n            if (K && \"start\" !== K && this.xData[0] >= e[0]) {\n              x = this.groupMap[0].start;\n              C = this.groupMap[0].length;\n              var H = void 0;\n              q(x) && q(C) && (H = x + (C - 1));\n              e[0] = {\n                middle: e[0] + .5 * z,\n                end: e[0] + z,\n                firstPoint: this.xData[0],\n                lastPoint: H && this.xData[H]\n              }[K];\n            }\n\n            m && \"start\" !== m && z && e[a] >= k - z && (k = this.groupMap[this.groupMap.length - 1].start, e[a] = {\n              middle: e[a] + .5 * z,\n              end: e[a] + z,\n              firstPoint: k && this.xData[k],\n              lastPoint: this.xData[this.xData.length - 1]\n            }[m]);\n          }\n\n          for (k = 1; k < f.length; k++) {\n            f.info.segmentStarts && -1 !== f.info.segmentStarts.indexOf(k) || (b = Math.max(f[k] - f[k - 1], b));\n          }\n\n          k = f.info;\n          k.gapSize = b;\n          this.closestPointRange = f.info.totalRange;\n          this.groupMap = B.groupMap;\n\n          if (n) {\n            n = p;\n\n            if (E(n[0]) && q(w.min) && q(w.dataMin) && n[0] < w.min) {\n              if (!E(w.options.min) && w.min <= w.dataMin || w.min === w.dataMin) w.min = Math.min(n[0], w.min);\n              w.dataMin = Math.min(n[0], w.dataMin);\n            }\n\n            if (E(n[n.length - 1]) && q(w.max) && q(w.dataMax) && n[n.length - 1] > w.max) {\n              if (!E(w.options.max) && q(w.dataMax) && w.max >= w.dataMax || w.max === w.dataMax) w.max = Math.max(n[n.length - 1], w.max);\n              w.dataMax = Math.max(n[n.length - 1], w.dataMax);\n            }\n          }\n\n          c.groupAll && (this.allGroupedData = g, c = this.cropData(p, g, w.min, w.max, 1), p = c.xData, g = c.yData, this.cropStart = c.start);\n          this.processedXData = p;\n          this.processedYData = g;\n        } else this.groupMap = null;\n\n        this.hasGroupedData = h;\n        this.currentDataGrouping = k;\n        this.preventGraphAnimation = (u && u.totalRange) !== (k && k.totalRange);\n      }\n    };\n\n    d.destroyGroupedData = function () {\n      this.groupedData && (this.groupedData.forEach(function (f, e) {\n        f && (this.groupedData[e] = f.destroy ? f.destroy() : null);\n      }, this), this.groupedData.length = 0);\n    };\n\n    d.generatePoints = function () {\n      g.apply(this);\n      this.destroyGroupedData();\n      this.groupedData = this.hasGroupedData ? this.points : null;\n    };\n\n    a.prototype.applyGrouping = function (f) {\n      var e = this,\n          c = e.series;\n      c.forEach(function (c) {\n        c.groupPixelWidth = void 0;\n      });\n      c.forEach(function (c) {\n        c.groupPixelWidth = e.getGroupPixelWidth && e.getGroupPixelWidth();\n        c.groupPixelWidth && (c.hasProcessed = !0);\n        c.applyGrouping(!!f.hasExtemesChanged);\n      });\n    };\n\n    a.prototype.getGroupPixelWidth = function () {\n      var f = this.series,\n          e = f.length,\n          c,\n          p = 0,\n          n = !1,\n          h;\n\n      for (c = e; c--;) {\n        (h = f[c].options.dataGrouping) && (p = Math.max(p, N(h.groupPixelWidth, O.groupPixelWidth)));\n      }\n\n      for (c = e; c--;) {\n        if (h = f[c].options.dataGrouping) if (e = (f[c].processedXData || f[c].data).length, f[c].groupPixelWidth || e > this.chart.plotSizeX / p || e && h.forced) n = !0;\n      }\n\n      return n ? p : 0;\n    };\n\n    a.prototype.setDataGrouping = function (f, e) {\n      var c;\n      e = N(e, !0);\n      f || (f = {\n        forced: !1,\n        units: null\n      });\n      if (this instanceof a) for (c = this.series.length; c--;) {\n        this.series[c].update({\n          dataGrouping: f\n        }, !1);\n      } else this.chart.options.series.forEach(function (c) {\n        c.dataGrouping = \"boolean\" === typeof f ? f : R(f, c.dataGrouping);\n      });\n      this.ordinal && (this.ordinal.slope = void 0);\n      e && this.chart.redraw();\n    };\n\n    A(a, \"postProcessData\", a.prototype.applyGrouping);\n    A(y, \"update\", function () {\n      if (this.dataGroup) return L(24, !1, this.series.chart), !1;\n    });\n    A(D, \"headerFormatter\", function (f) {\n      var e = this.chart,\n          c = e.time,\n          p = f.labelConfig,\n          n = p.series,\n          h = n.tooltipOptions,\n          u = n.options.dataGrouping,\n          w = h.xDateFormat,\n          g = n.xAxis,\n          b = h[f.isFooter ? \"footerFormat\" : \"headerFormat\"];\n\n      if (g && \"datetime\" === g.options.type && u && q(p.key)) {\n        var d = n.currentDataGrouping;\n        u = u.dateTimeLabelFormats || O.dateTimeLabelFormats;\n        if (d) {\n          if (h = u[d.unitName], 1 === d.count) w = h[0];else {\n            w = h[1];\n            var k = h[2];\n          }\n        } else !w && u && g.dateTime && (w = g.dateTime.getXDateFormat(p.x, h.dateTimeLabelFormats));\n        w = c.dateFormat(w, p.key);\n        k && (w += c.dateFormat(k, p.key + d.totalRange - 1));\n        n.chart.styledMode && (b = this.styledModeFormat(b));\n        f.text = m(b, {\n          point: H(p.point, {\n            key: w\n          }),\n          series: n\n        }, e);\n        f.preventDefault();\n      }\n    });\n    A(r, \"destroy\", d.destroyGroupedData);\n    A(r, \"afterSetOptions\", function (f) {\n      f = f.options;\n      var e = this.type,\n          c = this.chart.options.plotOptions,\n          p = t.defaultOptions.plotOptions[e].dataGrouping,\n          n = this.useCommonDataGrouping && O;\n\n      if (c && (x[e] || n)) {\n        p || (p = R(O, x[e]));\n        var h = this.chart.rangeSelector;\n        f.dataGrouping = R(n, p, c.series && c.series.dataGrouping, c[e].dataGrouping, this.userOptions.dataGrouping, !f.isInternal && h && q(h.selected) && h.buttonOptions[h.selected].dataGrouping);\n      }\n    });\n    A(a, \"afterSetScale\", function () {\n      this.series.forEach(function (f) {\n        f.hasProcessed = !1;\n      });\n    });\n    l.dataGrouping = M;\n    \"\";\n    \"\";\n    return M;\n  });\n  J(a, \"Series/HLC/HLCPoint.js\", [a[\"Core/Series/SeriesRegistry.js\"]], function (a) {\n    var v = this && this.__extends || function () {\n      var _a = function a(l, y) {\n        _a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, l) {\n          a.__proto__ = l;\n        } || function (a, l) {\n          for (var t in l) {\n            l.hasOwnProperty(t) && (a[t] = l[t]);\n          }\n        };\n\n        return _a(l, y);\n      };\n\n      return function (l, y) {\n        function r() {\n          this.constructor = l;\n        }\n\n        _a(l, y);\n\n        l.prototype = null === y ? Object.create(y) : (r.prototype = y.prototype, new r());\n      };\n    }();\n\n    return function (a) {\n      function l() {\n        var l = null !== a && a.apply(this, arguments) || this;\n        l.close = void 0;\n        l.high = void 0;\n        l.low = void 0;\n        l.options = void 0;\n        l.plotClose = void 0;\n        l.series = void 0;\n        return l;\n      }\n\n      v(l, a);\n      return l;\n    }(a.seriesTypes.column.prototype.pointClass);\n  });\n  J(a, \"Series/HLC/HLCSeries.js\", [a[\"Series/HLC/HLCPoint.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, v, A) {\n    var l = this && this.__extends || function () {\n      var _a2 = function a(b, m) {\n        _a2 = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, m) {\n          b.__proto__ = m;\n        } || function (b, m) {\n          for (var k in m) {\n            m.hasOwnProperty(k) && (b[k] = m[k]);\n          }\n        };\n\n        return _a2(b, m);\n      };\n\n      return function (b, m) {\n        function d() {\n          this.constructor = b;\n        }\n\n        _a2(b, m);\n\n        b.prototype = null === m ? Object.create(m) : (d.prototype = m.prototype, new d());\n      };\n    }(),\n        y = v.seriesTypes.column,\n        r = A.extend,\n        D = A.merge;\n\n    A = function (a) {\n      function b() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        b.yData = void 0;\n        return b;\n      }\n\n      l(b, a);\n\n      b.prototype.extendStem = function (b, d, a) {\n        var k = b[0];\n        b = b[1];\n        \"number\" === typeof k[2] && (k[2] = Math.max(a + d, k[2]));\n        \"number\" === typeof b[2] && (b[2] = Math.min(a - d, b[2]));\n      };\n\n      b.prototype.getPointPath = function (b, d) {\n        d = d.strokeWidth();\n        var a = b.series,\n            k = d % 2 / 2,\n            m = Math.round(b.plotX) - k,\n            E = Math.round(b.shapeArgs.width / 2);\n        var L = [[\"M\", m, Math.round(b.yBottom)], [\"L\", m, Math.round(b.plotHigh)]];\n        null !== b.close && (b = Math.round(b.plotClose) + k, L.push([\"M\", m, b], [\"L\", m + E, b]), a.extendStem(L, d / 2, b));\n        return L;\n      };\n\n      b.prototype.drawSinglePoint = function (b) {\n        var d = b.series,\n            a = d.chart,\n            k = b.graphic,\n            m = !k;\n        \"undefined\" !== typeof b.plotY && (k || (b.graphic = k = a.renderer.path().add(d.group)), a.styledMode || k.attr(d.pointAttribs(b, b.selected && \"select\")), d = d.getPointPath(b, k), k[m ? \"attr\" : \"animate\"]({\n          d: d\n        }).addClass(b.getClassName(), !0));\n      };\n\n      b.prototype.drawPoints = function () {\n        this.points.forEach(this.drawSinglePoint);\n      };\n\n      b.prototype.init = function () {\n        a.prototype.init.apply(this, arguments);\n        this.options.stacking = void 0;\n      };\n\n      b.prototype.pointAttribs = function (b, d) {\n        b = a.prototype.pointAttribs.call(this, b, d);\n        delete b.fill;\n        return b;\n      };\n\n      b.prototype.toYData = function (b) {\n        return [b.high, b.low, b.close];\n      };\n\n      b.prototype.translate = function () {\n        var b = this,\n            d = b.yAxis,\n            l = this.pointArrayMap && this.pointArrayMap.slice() || [],\n            k = l.map(function (b) {\n          return \"plot\".concat(b.charAt(0).toUpperCase() + b.slice(1));\n        });\n        k.push(\"yBottom\");\n        l.push(\"low\");\n        a.prototype.translate.apply(b);\n        b.points.forEach(function (a) {\n          l.forEach(function (m, L) {\n            m = a[m];\n            null !== m && (b.dataModify && (m = b.dataModify.modifyValue(m)), a[k[L]] = d.toPixels(m, !0));\n          });\n          a.tooltipPos[1] = a.plotHigh + d.pos - b.chart.plotTop;\n        });\n      };\n\n      b.defaultOptions = D(y.defaultOptions, {\n        lineWidth: 1,\n        tooltip: {\n          pointFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> <b> {series.name}</b><br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>\"\n        },\n        threshold: null,\n        states: {\n          hover: {\n            lineWidth: 3\n          }\n        },\n        stickyTracking: !0\n      });\n      return b;\n    }(y);\n\n    r(A.prototype, {\n      animate: null,\n      directTouch: !1,\n      pointArrayMap: [\"high\", \"low\", \"close\"],\n      pointAttrToOptions: {\n        stroke: \"color\",\n        \"stroke-width\": \"lineWidth\"\n      },\n      pointValKey: \"close\"\n    });\n    A.prototype.pointClass = a;\n    v.registerSeriesType(\"hlc\", A);\n    \"\";\n    return A;\n  });\n  J(a, \"Series/OHLC/OHLCPoint.js\", [a[\"Core/Series/SeriesRegistry.js\"]], function (a) {\n    var v = this && this.__extends || function () {\n      var _a3 = function a(l, y) {\n        _a3 = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, l) {\n          a.__proto__ = l;\n        } || function (a, l) {\n          for (var t in l) {\n            l.hasOwnProperty(t) && (a[t] = l[t]);\n          }\n        };\n\n        return _a3(l, y);\n      };\n\n      return function (l, y) {\n        function r() {\n          this.constructor = l;\n        }\n\n        _a3(l, y);\n\n        l.prototype = null === y ? Object.create(y) : (r.prototype = y.prototype, new r());\n      };\n    }();\n\n    return function (a) {\n      function l() {\n        var l = null !== a && a.apply(this, arguments) || this;\n        l.open = void 0;\n        l.options = void 0;\n        l.plotOpen = void 0;\n        l.series = void 0;\n        return l;\n      }\n\n      v(l, a);\n\n      l.prototype.getClassName = function () {\n        return a.prototype.getClassName.call(this) + (this.open < this.close ? \" highcharts-point-up\" : \" highcharts-point-down\");\n      };\n\n      l.prototype.resolveUpColor = function () {\n        this.open < this.close && !this.options.color && this.series.options.upColor && (this.color = this.series.options.upColor);\n      };\n\n      l.prototype.resolveColor = function () {\n        a.prototype.resolveColor.call(this);\n        this.resolveUpColor();\n      };\n\n      l.prototype.getZone = function () {\n        var l = a.prototype.getZone.call(this);\n        this.resolveUpColor();\n        return l;\n      };\n\n      l.prototype.applyOptions = function () {\n        a.prototype.applyOptions.apply(this, arguments);\n        this.resolveColor && this.resolveColor();\n        return this;\n      };\n\n      return l;\n    }(a.seriesTypes.hlc.prototype.pointClass);\n  });\n  J(a, \"Series/OHLC/OHLCSeries.js\", [a[\"Series/OHLC/OHLCPoint.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, v, A) {\n    var l = this && this.__extends || function () {\n      var _b = function b(d, k) {\n        _b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, k) {\n          b.__proto__ = k;\n        } || function (b, k) {\n          for (var d in k) {\n            k.hasOwnProperty(d) && (b[d] = k[d]);\n          }\n        };\n\n        return _b(d, k);\n      };\n\n      return function (d, k) {\n        function a() {\n          this.constructor = d;\n        }\n\n        _b(d, k);\n\n        d.prototype = null === k ? Object.create(k) : (a.prototype = k.prototype, new a());\n      };\n    }(),\n        y = v.series,\n        r = v.seriesTypes.hlc,\n        D = A.addEvent,\n        t = A.extend,\n        b = A.merge,\n        m = function (d) {\n      function a() {\n        var b = null !== d && d.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      l(a, d);\n\n      a.prototype.getPointPath = function (b, a) {\n        var k = d.prototype.getPointPath.call(this, b, a);\n        a = a.strokeWidth();\n        var m = a % 2 / 2,\n            l = Math.round(b.plotX) - m,\n            q = Math.round(b.shapeArgs.width / 2);\n        null !== b.open && (b = Math.round(b.plotOpen) + m, k.push([\"M\", l, b], [\"L\", l - q, b]), d.prototype.extendStem.call(this, k, a / 2, b));\n        return k;\n      };\n\n      a.prototype.pointAttribs = function (b, a) {\n        a = d.prototype.pointAttribs.call(this, b, a);\n        var k = this.options;\n        delete a.fill;\n        !b.options.color && k.upColor && b.open < b.close && (a.stroke = k.upColor);\n        return a;\n      };\n\n      a.prototype.toYData = function (b) {\n        return [b.open, b.high, b.low, b.close];\n      };\n\n      a.defaultOptions = b(r.defaultOptions, {\n        tooltip: {\n          pointFormat: \"<span style=\\\"color:{point.color}\\\">\\u25CF</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>\"\n        }\n      });\n      return a;\n    }(r);\n\n    t(m.prototype, {\n      pointArrayMap: [\"open\", \"high\", \"low\", \"close\"]\n    });\n    m.prototype.pointClass = a;\n    v.registerSeriesType(\"ohlc\", m);\n    D(y, \"init\", function (b) {\n      b = b.options;\n      b.useOhlcData && \"highcharts-navigator-series\" !== b.id && t(this, {\n        pointValKey: m.prototype.pointValKey,\n        pointArrayMap: m.prototype.pointArrayMap,\n        toYData: m.prototype.toYData\n      });\n    });\n    D(y, \"afterSetOptions\", function (b) {\n      b = b.options;\n      var a = b.dataGrouping;\n      a && b.useOhlcData && \"highcharts-navigator-series\" !== b.id && (a.approximation = \"ohlc\");\n    });\n    \"\";\n    return m;\n  });\n  J(a, \"Series/Candlestick/CandlestickSeries.js\", [a[\"Core/DefaultOptions.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, v, A) {\n    var l = this && this.__extends || function () {\n      var _b2 = function b(a, d) {\n        _b2 = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, a) {\n          b.__proto__ = a;\n        } || function (b, a) {\n          for (var d in a) {\n            a.hasOwnProperty(d) && (b[d] = a[d]);\n          }\n        };\n\n        return _b2(a, d);\n      };\n\n      return function (a, d) {\n        function m() {\n          this.constructor = a;\n        }\n\n        _b2(a, d);\n\n        a.prototype = null === d ? Object.create(d) : (m.prototype = d.prototype, new m());\n      };\n    }(),\n        y = a.defaultOptions;\n\n    a = v.seriesTypes;\n    var r = a.column,\n        D = a.ohlc,\n        t = A.merge;\n\n    A = function (b) {\n      function a() {\n        var a = null !== b && b.apply(this, arguments) || this;\n        a.data = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      l(a, b);\n\n      a.prototype.pointAttribs = function (b, a) {\n        var d = r.prototype.pointAttribs.call(this, b, a),\n            m = this.options,\n            l = b.open < b.close,\n            L = m.lineColor || this.color,\n            H = b.color || this.color;\n        d[\"stroke-width\"] = m.lineWidth;\n        d.fill = b.options.color || (l ? m.upColor || H : H);\n        d.stroke = b.options.lineColor || (l ? m.upLineColor || L : L);\n        a && (b = m.states[a], d.fill = b.color || d.fill, d.stroke = b.lineColor || d.stroke, d[\"stroke-width\"] = b.lineWidth || d[\"stroke-width\"]);\n        return d;\n      };\n\n      a.prototype.drawPoints = function () {\n        var b = this,\n            a = b.chart,\n            k = b.yAxis.reversed;\n        b.points.forEach(function (d) {\n          var m = d.graphic,\n              l = !m;\n\n          if (\"undefined\" !== typeof d.plotY) {\n            m || (d.graphic = m = a.renderer.path().add(b.group));\n            b.chart.styledMode || m.attr(b.pointAttribs(d, d.selected && \"select\")).shadow(b.options.shadow);\n            var H = m.strokeWidth() % 2 / 2;\n            var q = Math.round(d.plotX) - H;\n            var t = d.plotOpen;\n            var r = d.plotClose;\n            var F = Math.min(t, r);\n            t = Math.max(t, r);\n            var y = Math.round(d.shapeArgs.width / 2);\n            r = k ? t !== d.yBottom : Math.round(F) !== Math.round(d.plotHigh);\n            var g = k ? Math.round(F) !== Math.round(d.plotHigh) : t !== d.yBottom;\n            F = Math.round(F) + H;\n            t = Math.round(t) + H;\n            H = [];\n            H.push([\"M\", q - y, t], [\"L\", q - y, F], [\"L\", q + y, F], [\"L\", q + y, t], [\"Z\"], [\"M\", q, F], [\"L\", q, r ? Math.round(k ? d.yBottom : d.plotHigh) : F], [\"M\", q, t], [\"L\", q, g ? Math.round(k ? d.plotHigh : d.yBottom) : t]);\n            m[l ? \"attr\" : \"animate\"]({\n              d: H\n            }).addClass(d.getClassName(), !0);\n          }\n        });\n      };\n\n      a.defaultOptions = t(D.defaultOptions, y.plotOptions, {\n        states: {\n          hover: {\n            lineWidth: 2\n          }\n        },\n        tooltip: y.plotOptions.ohlc.tooltip,\n        threshold: null,\n        lineColor: \"#000000\",\n        lineWidth: 1,\n        upColor: \"#ffffff\",\n        stickyTracking: !0\n      });\n      return a;\n    }(D);\n\n    v.registerSeriesType(\"candlestick\", A);\n    \"\";\n    return A;\n  });\n  J(a, \"Series/Flags/FlagsPoint.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, v) {\n    var A = this && this.__extends || function () {\n      var _a4 = function a(l, y) {\n        _a4 = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var m in b) {\n            b.hasOwnProperty(m) && (a[m] = b[m]);\n          }\n        };\n\n        return _a4(l, y);\n      };\n\n      return function (l, y) {\n        function t() {\n          this.constructor = l;\n        }\n\n        _a4(l, y);\n\n        l.prototype = null === y ? Object.create(y) : (t.prototype = y.prototype, new t());\n      };\n    }(),\n        l = v.isNumber;\n\n    return function (a) {\n      function r() {\n        var l = null !== a && a.apply(this, arguments) || this;\n        l.options = void 0;\n        l.series = void 0;\n        l.ttBelow = !1;\n        return l;\n      }\n\n      A(r, a);\n\n      r.prototype.isValid = function () {\n        return l(this.y) || \"undefined\" === typeof this.y;\n      };\n\n      r.prototype.hasNewShapeType = function () {\n        var a = this.options.shape || this.series.options.shape;\n        return this.graphic && a && a !== this.graphic.symbolKey;\n      };\n\n      return r;\n    }(a.seriesTypes.column.prototype.pointClass);\n  });\n  J(a, \"Series/OnSeriesComposition.js\", [a[\"Series/Column/ColumnSeries.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Utilities.js\"]], function (a, v, A) {\n    var l = a.prototype,\n        y = v.prototype,\n        r = A.defined,\n        D = A.stableSort,\n        t;\n\n    (function (b) {\n      function a() {\n        return y.getPlotBox.call(this.options.onSeries && this.chart.get(this.options.onSeries) || this);\n      }\n\n      function d() {\n        l.translate.apply(this);\n        var b = this,\n            a = b.options,\n            d = b.chart,\n            m = b.points,\n            H = a.onSeries,\n            q = (H = H && d.get(H)) && H.options.step,\n            t = H && H.points,\n            y = d.inverted,\n            F = b.xAxis,\n            v = b.yAxis;\n        d = m.length - 1;\n        var g;\n        a = a.onKey || \"y\";\n        var C = t && t.length,\n            x = 0,\n            I;\n\n        if (H && H.visible && C) {\n          x = (H.pointXOffset || 0) + (H.barW || 0) / 2;\n          var f = H.currentDataGrouping;\n          var e = t[C - 1].x + (f ? f.totalRange : 0);\n          D(m, function (c, h) {\n            return c.x - h.x;\n          });\n\n          for (a = \"plot\" + a[0].toUpperCase() + a.substr(1); C-- && m[d];) {\n            var c = t[C];\n            f = m[d];\n            f.y = c.y;\n\n            if (c.x <= f.x && \"undefined\" !== typeof c[a]) {\n              if (f.x <= e && (f.plotY = c[a], c.x < f.x && !q && (I = t[C + 1]) && \"undefined\" !== typeof I[a])) {\n                var p = (f.x - c.x) / (I.x - c.x);\n                f.plotY += p * (I[a] - c[a]);\n                f.y += p * (I.y - c.y);\n              }\n\n              d--;\n              C++;\n              if (0 > d) break;\n            }\n          }\n        }\n\n        m.forEach(function (c, h) {\n          c.plotX += x;\n          if (\"undefined\" === typeof c.plotY || y) 0 <= c.plotX && c.plotX <= F.len ? y ? (c.plotY = F.translate(c.x, 0, 1, 0, 1), c.plotX = r(c.y) ? v.translate(c.y, 0, 0, 0, 1) : 0) : c.plotY = (F.opposite ? 0 : b.yAxis.len) + F.offset : c.shapeArgs = {};\n\n          if ((g = m[h - 1]) && g.plotX === c.plotX) {\n            \"undefined\" === typeof g.stackIndex && (g.stackIndex = 0);\n            var u = g.stackIndex + 1;\n          }\n\n          c.stackIndex = u;\n        });\n        this.onSeries = H;\n      }\n\n      var t = [];\n\n      b.compose = function (b) {\n        if (-1 === t.indexOf(b)) {\n          t.push(b);\n          var k = b.prototype;\n          k.getPlotBox = a;\n          k.translate = d;\n        }\n\n        return b;\n      };\n\n      b.getPlotBox = a;\n      b.translate = d;\n    })(t || (t = {}));\n\n    return t;\n  });\n  J(a, \"Series/Flags/FlagsSymbols.js\", [a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"]], function (a, v) {\n    function A(a) {\n      l[a + \"pin\"] = function (r, y, t, b, m) {\n        var d = m && m.anchorX;\n        m = m && m.anchorY;\n        \"circle\" === a && b > t && (r -= Math.round((b - t) / 2), t = b);\n        var C = l[a](r, y, t, b);\n\n        if (d && m) {\n          var k = d;\n          \"circle\" === a ? k = r + t / 2 : (r = C[0], t = C[1], \"M\" === r[0] && \"L\" === t[0] && (k = (r[1] + t[1]) / 2));\n          C.push([\"M\", k, y > m ? y : y + b], [\"L\", d, m]);\n          C = C.concat(l.circle(d - 1, m - 1, 2, 2));\n        }\n\n        return C;\n      };\n    }\n\n    var l = v.prototype.symbols;\n\n    l.flag = function (a, r, v, t, b) {\n      var m = b && b.anchorX || a;\n      b = b && b.anchorY || r;\n      var d = l.circle(m - 1, b - 1, 2, 2);\n      d.push([\"M\", m, b], [\"L\", a, r + t], [\"L\", a, r], [\"L\", a + v, r], [\"L\", a + v, r + t], [\"L\", a, r + t], [\"Z\"]);\n      return d;\n    };\n\n    A(\"circle\");\n    A(\"square\");\n    a = a.getRendererType();\n    a !== v && (a.prototype.symbols.circlepin = l.circlepin, a.prototype.symbols.flag = l.flag, a.prototype.symbols.squarepin = l.squarepin);\n    return l;\n  });\n  J(a, \"Series/Flags/FlagsSeries.js\", [a[\"Series/Flags/FlagsPoint.js\"], a[\"Core/Globals.js\"], a[\"Series/OnSeriesComposition.js\"], a[\"Core/Renderer/RendererUtilities.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, v, A, l, y, r, D) {\n    var t = this && this.__extends || function () {\n      var _b3 = function b(a, d) {\n        _b3 = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, a) {\n          b.__proto__ = a;\n        } || function (b, a) {\n          for (var d in a) {\n            a.hasOwnProperty(d) && (b[d] = a[d]);\n          }\n        };\n\n        return _b3(a, d);\n      };\n\n      return function (a, d) {\n        function q() {\n          this.constructor = a;\n        }\n\n        _b3(a, d);\n\n        a.prototype = null === d ? Object.create(d) : (q.prototype = d.prototype, new q());\n      };\n    }();\n\n    v = v.noop;\n    var b = l.distribute,\n        m = y.series,\n        d = y.seriesTypes.column,\n        C = D.addEvent,\n        k = D.defined;\n    l = D.extend;\n    var K = D.merge,\n        E = D.objectEach,\n        L = D.wrap;\n\n    D = function (a) {\n      function q() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      t(q, a);\n\n      q.prototype.animate = function (b) {\n        b && this.setClip();\n      };\n\n      q.prototype.drawPoints = function () {\n        var a = this.points,\n            d = this.chart,\n            q = d.renderer,\n            m = d.inverted,\n            g = this.options,\n            l = g.y,\n            x,\n            t = this.yAxis,\n            f = {},\n            e = [];\n\n        for (x = a.length; x--;) {\n          var c = a[x];\n          var p = (m ? c.plotY : c.plotX) > this.xAxis.len;\n          var n = c.plotX;\n          var h = c.stackIndex;\n          var u = c.options.shape || g.shape;\n          var w = c.plotY;\n          \"undefined\" !== typeof w && (w = c.plotY + l - (\"undefined\" !== typeof h && h * g.stackDistance));\n          c.anchorX = h ? void 0 : c.plotX;\n          var P = h ? void 0 : c.plotY;\n          var Q = \"flag\" !== u;\n          h = c.graphic;\n          \"undefined\" !== typeof w && 0 <= n && !p ? (h && c.hasNewShapeType() && (h = h.destroy()), h || (h = c.graphic = q.label(\"\", null, null, u, null, null, g.useHTML).addClass(\"highcharts-point\").add(this.markerGroup), c.graphic.div && (c.graphic.div.point = c), h.isNew = !0), h.attr({\n            align: Q ? \"center\" : \"left\",\n            width: g.width,\n            height: g.height,\n            \"text-align\": g.textAlign\n          }), d.styledMode || h.attr(this.pointAttribs(c)).css(K(g.style, c.style)).shadow(g.shadow), 0 < n && (n -= h.strokeWidth() % 2), u = {\n            y: w,\n            anchorY: P\n          }, g.allowOverlapX && (u.x = n, u.anchorX = c.anchorX), h.attr({\n            text: c.options.title || g.title || \"A\"\n          })[h.isNew ? \"attr\" : \"animate\"](u), g.allowOverlapX || (f[c.plotX] ? f[c.plotX].size = Math.max(f[c.plotX].size, h.width) : f[c.plotX] = {\n            align: Q ? .5 : 0,\n            size: h.width,\n            target: n,\n            anchorX: n\n          }), c.tooltipPos = [n, w + t.pos - d.plotTop]) : h && (c.graphic = h.destroy());\n        }\n\n        if (!g.allowOverlapX) {\n          var B = 100;\n          E(f, function (h) {\n            h.plotX = h.anchorX;\n            e.push(h);\n            B = Math.max(h.size, B);\n          });\n          b(e, m ? t.len : this.xAxis.len, B);\n          a.forEach(function (h) {\n            var c = h.plotX,\n                u = h.graphic;\n            (c = u && f[c]) && u && (k(c.pos) ? u[u.isNew ? \"attr\" : \"animate\"]({\n              x: c.pos + (c.align || 0) * c.size,\n              anchorX: h.anchorX\n            }).show().isNew = !1 : u.hide().isNew = !0);\n          });\n        }\n\n        g.useHTML && L(this.markerGroup, \"on\", function (h) {\n          return r.prototype.on.apply(h.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));\n        });\n      };\n\n      q.prototype.drawTracker = function () {\n        var b = this.points;\n        a.prototype.drawTracker.call(this);\n        b.forEach(function (a) {\n          var d = a.graphic;\n          d && (a.unbindMouseOver && a.unbindMouseOver(), a.unbindMouseOver = C(d.element, \"mouseover\", function () {\n            0 < a.stackIndex && !a.raised && (a._y = d.y, d.attr({\n              y: a._y - 8\n            }), a.raised = !0);\n            b.forEach(function (b) {\n              b !== a && b.raised && b.graphic && (b.graphic.attr({\n                y: b._y\n              }), b.raised = !1);\n            });\n          }));\n        });\n      };\n\n      q.prototype.pointAttribs = function (b, a) {\n        var d = this.options,\n            q = b && b.color || this.color,\n            g = d.lineColor,\n            k = b && b.lineWidth;\n        b = b && b.fillColor || d.fillColor;\n        a && (b = d.states[a].fillColor, g = d.states[a].lineColor, k = d.states[a].lineWidth);\n        return {\n          fill: b || q,\n          stroke: g || q,\n          \"stroke-width\": k || d.lineWidth || 0\n        };\n      };\n\n      q.prototype.setClip = function () {\n        m.prototype.setClip.apply(this, arguments);\n        !1 !== this.options.clip && this.sharedClipKey && this.markerGroup && this.markerGroup.clip(this.chart.sharedClips[this.sharedClipKey]);\n      };\n\n      q.defaultOptions = K(d.defaultOptions, {\n        pointRange: 0,\n        allowOverlapX: !1,\n        shape: \"flag\",\n        stackDistance: 12,\n        textAlign: \"center\",\n        tooltip: {\n          pointFormat: \"{point.text}\"\n        },\n        threshold: null,\n        y: -30,\n        fillColor: \"#ffffff\",\n        lineWidth: 1,\n        states: {\n          hover: {\n            lineColor: \"#000000\",\n            fillColor: \"#ccd6eb\"\n          }\n        },\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\"\n        }\n      });\n      return q;\n    }(d);\n\n    A.compose(D);\n    l(D.prototype, {\n      allowDG: !1,\n      forceCrop: !0,\n      invertible: !1,\n      noSharedTooltip: !0,\n      pointClass: a,\n      sorted: !1,\n      takeOrdinalPosition: !1,\n      trackerGroups: [\"markerGroup\"],\n      buildKDTree: v,\n      init: m.prototype.init,\n      invertGroups: v\n    });\n    y.registerSeriesType(\"flags\", D);\n    \"\";\n    \"\";\n    return D;\n  });\n  J(a, \"Core/Axis/ScrollbarAxis.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    var v = a.addEvent,\n        A = a.defined,\n        l = a.pick;\n    return function () {\n      function a() {}\n\n      a.compose = function (r, y) {\n        if (-1 === a.composed.indexOf(r)) a.composed.push(r);else return r;\n\n        var t = function t(b) {\n          var a = l(b.options && b.options.min, b.min),\n              d = l(b.options && b.options.max, b.max);\n          return {\n            axisMin: a,\n            axisMax: d,\n            scrollMin: A(b.dataMin) ? Math.min(a, b.min, b.dataMin, l(b.threshold, Infinity)) : a,\n            scrollMax: A(b.dataMax) ? Math.max(d, b.max, b.dataMax, l(b.threshold, -Infinity)) : d\n          };\n        };\n\n        v(r, \"afterInit\", function () {\n          var b = this;\n          b.options && b.options.scrollbar && b.options.scrollbar.enabled && (b.options.scrollbar.vertical = !b.horiz, b.options.startOnTick = b.options.endOnTick = !1, b.scrollbar = new y(b.chart.renderer, b.options.scrollbar, b.chart), v(b.scrollbar, \"changed\", function (a) {\n            var d = t(b),\n                m = d.axisMax,\n                k = d.scrollMin,\n                l = d.scrollMax - k;\n            A(d.axisMin) && A(m) && (b.horiz && !b.reversed || !b.horiz && b.reversed ? (d = k + l * this.to, k += l * this.from) : (d = k + l * (1 - this.from), k += l * (1 - this.to)), this.shouldUpdateExtremes(a.DOMType) ? b.setExtremes(k, d, !0, \"mousemove\" !== a.DOMType && \"touchmove\" !== a.DOMType, a) : this.setRange(this.from, this.to));\n          }));\n        });\n        v(r, \"afterRender\", function () {\n          var b = t(this),\n              a = b.scrollMin,\n              d = b.scrollMax;\n          b = this.scrollbar;\n          var l = this.axisTitleMargin + (this.titleOffset || 0),\n              k = this.chart.scrollbarsOffsets,\n              r = this.options.margin || 0;\n          b && (this.horiz ? (this.opposite || (k[1] += l), b.position(this.left, this.top + this.height + 2 + k[1] - (this.opposite ? r : 0), this.width, this.height), this.opposite || (k[1] += r), l = 1) : (this.opposite && (k[0] += l), b.position(b.options.opposite ? this.left + this.width + 2 + k[0] - (this.opposite ? 0 : r) : this.opposite ? 0 : r, this.top, this.width, this.height), this.opposite && (k[0] += r), l = 0), k[l] += b.size + b.options.margin, isNaN(a) || isNaN(d) || !A(this.min) || !A(this.max) || this.min === this.max ? b.setRange(0, 1) : (k = (this.min - a) / (d - a), a = (this.max - a) / (d - a), this.horiz && !this.reversed || !this.horiz && this.reversed ? b.setRange(k, a) : b.setRange(1 - a, 1 - k)));\n        });\n        v(r, \"afterGetOffset\", function () {\n          var b = this.scrollbar && !this.scrollbar.options.opposite;\n          b = this.horiz ? 2 : b ? 3 : 1;\n          var a = this.scrollbar;\n          a && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[b] += a.size + a.options.margin);\n        });\n        return r;\n      };\n\n      a.composed = [];\n      return a;\n    }();\n  });\n  J(a, \"Core/ScrollbarDefaults.js\", [a[\"Core/Globals.js\"]], function (a) {\n    return {\n      height: a.isTouchDevice ? 20 : 14,\n      barBorderRadius: 0,\n      buttonBorderRadius: 0,\n      liveRedraw: void 0,\n      margin: 10,\n      minWidth: 6,\n      opposite: !0,\n      step: .2,\n      zIndex: 3,\n      barBackgroundColor: \"#cccccc\",\n      barBorderWidth: 1,\n      barBorderColor: \"#cccccc\",\n      buttonArrowColor: \"#333333\",\n      buttonBackgroundColor: \"#e6e6e6\",\n      buttonBorderColor: \"#cccccc\",\n      buttonBorderWidth: 1,\n      rifleColor: \"#333333\",\n      trackBackgroundColor: \"#f2f2f2\",\n      trackBorderColor: \"#f2f2f2\",\n      trackBorderWidth: 1\n    };\n  });\n  J(a, \"Core/Scrollbar.js\", [a[\"Core/DefaultOptions.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/ScrollbarAxis.js\"], a[\"Core/ScrollbarDefaults.js\"], a[\"Core/Utilities.js\"]], function (a, v, A, l, y) {\n    var r = a.defaultOptions,\n        D = y.addEvent,\n        t = y.correctFloat,\n        b = y.defined,\n        m = y.destroyObjectProperties,\n        d = y.fireEvent,\n        C = y.merge,\n        k = y.pick,\n        K = y.removeEvent;\n\n    a = function () {\n      function a(a, b, d) {\n        this._events = [];\n        this.chart = void 0;\n        this.from = this.chartY = this.chartX = 0;\n        this.scrollbar = this.renderer = this.options = this.group = void 0;\n        this.scrollbarButtons = [];\n        this.scrollbarGroup = void 0;\n        this.scrollbarLeft = 0;\n        this.scrollbarRifles = void 0;\n        this.scrollbarStrokeWidth = 1;\n        this.to = this.size = this.scrollbarTop = 0;\n        this.track = void 0;\n        this.trackBorderWidth = 1;\n        this.userOptions = void 0;\n        this.y = this.x = 0;\n        this.init(a, b, d);\n      }\n\n      a.compose = function (b) {\n        A.compose(b, a);\n      };\n\n      a.swapXY = function (a, b) {\n        b && a.forEach(function (a) {\n          for (var b = a.length, d, q = 0; q < b; q += 2) {\n            d = a[q + 1], \"number\" === typeof d && (a[q + 1] = a[q + 2], a[q + 2] = d);\n          }\n        });\n        return a;\n      };\n\n      a.prototype.addEvents = function () {\n        var a = this.options.inverted ? [1, 0] : [0, 1],\n            b = this.scrollbarButtons,\n            d = this.scrollbarGroup.element,\n            k = this.track.element,\n            l = this.mouseDownHandler.bind(this),\n            m = this.mouseMoveHandler.bind(this),\n            t = this.mouseUpHandler.bind(this);\n        a = [[b[a[0]].element, \"click\", this.buttonToMinClick.bind(this)], [b[a[1]].element, \"click\", this.buttonToMaxClick.bind(this)], [k, \"click\", this.trackClick.bind(this)], [d, \"mousedown\", l], [d.ownerDocument, \"mousemove\", m], [d.ownerDocument, \"mouseup\", t]];\n        v.hasTouch && a.push([d, \"touchstart\", l], [d.ownerDocument, \"touchmove\", m], [d.ownerDocument, \"touchend\", t]);\n        a.forEach(function (a) {\n          D.apply(null, a);\n        });\n        this._events = a;\n      };\n\n      a.prototype.buttonToMaxClick = function (a) {\n        var b = (this.to - this.from) * k(this.options.step, .2);\n        this.updatePosition(this.from + b, this.to + b);\n        d(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: a\n        });\n      };\n\n      a.prototype.buttonToMinClick = function (a) {\n        var b = t(this.to - this.from) * k(this.options.step, .2);\n        this.updatePosition(t(this.from - b), t(this.to - b));\n        d(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: a\n        });\n      };\n\n      a.prototype.cursorToScrollbarPosition = function (a) {\n        var b = this.options;\n        b = b.minWidth > this.calculatedWidth ? b.minWidth : 0;\n        return {\n          chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - b),\n          chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - b)\n        };\n      };\n\n      a.prototype.destroy = function () {\n        var a = this,\n            b = a.chart.scroller;\n        a.removeEvents();\n        [\"track\", \"scrollbarRifles\", \"scrollbar\", \"scrollbarGroup\", \"group\"].forEach(function (b) {\n          a[b] && a[b].destroy && (a[b] = a[b].destroy());\n        });\n        b && a === b.scrollbar && (b.scrollbar = null, m(b.scrollbarButtons));\n      };\n\n      a.prototype.drawScrollbarButton = function (b) {\n        var d = this.renderer,\n            q = this.scrollbarButtons,\n            k = this.options,\n            l = this.size,\n            m = d.g().add(this.group);\n        q.push(m);\n        m = d.rect().addClass(\"highcharts-scrollbar-button\").add(m);\n        this.chart.styledMode || m.attr({\n          stroke: k.buttonBorderColor,\n          \"stroke-width\": k.buttonBorderWidth,\n          fill: k.buttonBackgroundColor\n        });\n        m.attr(m.crisp({\n          x: -.5,\n          y: -.5,\n          width: l + 1,\n          height: l + 1,\n          r: k.buttonBorderRadius\n        }, m.strokeWidth()));\n        m = d.path(a.swapXY([[\"M\", l / 2 + (b ? -1 : 1), l / 2 - 3], [\"L\", l / 2 + (b ? -1 : 1), l / 2 + 3], [\"L\", l / 2 + (b ? 2 : -2), l / 2]], k.vertical)).addClass(\"highcharts-scrollbar-arrow\").add(q[b]);\n        this.chart.styledMode || m.attr({\n          fill: k.buttonArrowColor\n        });\n      };\n\n      a.prototype.init = function (a, b, d) {\n        this.scrollbarButtons = [];\n        this.renderer = a;\n        this.userOptions = b;\n        this.options = C(l, r.scrollbar, b);\n        this.chart = d;\n        this.size = k(this.options.size, this.options.height);\n        b.enabled && (this.render(), this.addEvents());\n      };\n\n      a.prototype.mouseDownHandler = function (a) {\n        a = this.chart.pointer.normalize(a);\n        a = this.cursorToScrollbarPosition(a);\n        this.chartX = a.chartX;\n        this.chartY = a.chartY;\n        this.initPositions = [this.from, this.to];\n        this.grabbedCenter = !0;\n      };\n\n      a.prototype.mouseMoveHandler = function (a) {\n        var b = this.chart.pointer.normalize(a),\n            k = this.options.vertical ? \"chartY\" : \"chartX\",\n            l = this.initPositions || [];\n        !this.grabbedCenter || a.touches && 0 === a.touches[0][k] || (b = this.cursorToScrollbarPosition(b)[k], k = this[k], k = b - k, this.hasDragged = !0, this.updatePosition(l[0] + k, l[1] + k), this.hasDragged && d(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMType: a.type,\n          DOMEvent: a\n        }));\n      };\n\n      a.prototype.mouseUpHandler = function (a) {\n        this.hasDragged && d(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMType: a.type,\n          DOMEvent: a\n        });\n        this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;\n      };\n\n      a.prototype.position = function (a, b, d, k) {\n        var q = this.options.vertical,\n            l = this.rendered ? \"animate\" : \"attr\",\n            m = k,\n            g = 0;\n        this.group.show();\n        this.x = a;\n        this.y = b + this.trackBorderWidth;\n        this.width = d;\n        this.height = k;\n        this.xOffset = m;\n        this.yOffset = g;\n        q ? (this.width = this.yOffset = d = g = this.size, this.xOffset = m = 0, this.barWidth = k - 2 * d, this.x = a += this.options.margin) : (this.height = this.xOffset = k = m = this.size, this.barWidth = d - 2 * k, this.y += this.options.margin);\n        this.group[l]({\n          translateX: a,\n          translateY: this.y\n        });\n        this.track[l]({\n          width: d,\n          height: k\n        });\n        this.scrollbarButtons[1][l]({\n          translateX: q ? 0 : d - m,\n          translateY: q ? k - g : 0\n        });\n      };\n\n      a.prototype.removeEvents = function () {\n        this._events.forEach(function (a) {\n          K.apply(null, a);\n        });\n\n        this._events.length = 0;\n      };\n\n      a.prototype.render = function () {\n        var b = this.renderer,\n            d = this.options,\n            k = this.size,\n            l = this.chart.styledMode,\n            m = b.g(\"scrollbar\").attr({\n          zIndex: d.zIndex\n        }).hide().add();\n        this.group = m;\n        this.track = b.rect().addClass(\"highcharts-scrollbar-track\").attr({\n          x: 0,\n          r: d.trackBorderRadius || 0,\n          height: k,\n          width: k\n        }).add(m);\n        l || this.track.attr({\n          fill: d.trackBackgroundColor,\n          stroke: d.trackBorderColor,\n          \"stroke-width\": d.trackBorderWidth\n        });\n        this.trackBorderWidth = this.track.strokeWidth();\n        this.track.attr({\n          y: -this.trackBorderWidth % 2 / 2\n        });\n        this.scrollbarGroup = b.g().add(m);\n        this.scrollbar = b.rect().addClass(\"highcharts-scrollbar-thumb\").attr({\n          height: k,\n          width: k,\n          r: d.barBorderRadius || 0\n        }).add(this.scrollbarGroup);\n        this.scrollbarRifles = b.path(a.swapXY([[\"M\", -3, k / 4], [\"L\", -3, 2 * k / 3], [\"M\", 0, k / 4], [\"L\", 0, 2 * k / 3], [\"M\", 3, k / 4], [\"L\", 3, 2 * k / 3]], d.vertical)).addClass(\"highcharts-scrollbar-rifles\").add(this.scrollbarGroup);\n        l || (this.scrollbar.attr({\n          fill: d.barBackgroundColor,\n          stroke: d.barBorderColor,\n          \"stroke-width\": d.barBorderWidth\n        }), this.scrollbarRifles.attr({\n          stroke: d.rifleColor,\n          \"stroke-width\": 1\n        }));\n        this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();\n        this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);\n        this.drawScrollbarButton(0);\n        this.drawScrollbarButton(1);\n      };\n\n      a.prototype.setRange = function (a, d) {\n        var k = this.options,\n            l = k.vertical,\n            m = k.minWidth,\n            r = this.barWidth,\n            v = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? \"attr\" : \"animate\";\n\n        if (b(r)) {\n          var g = r * Math.min(d, 1);\n          a = Math.max(a, 0);\n          var y = Math.ceil(r * a);\n          this.calculatedWidth = g = t(g - y);\n          g < m && (y = (r - m + g) * a, g = m);\n          m = Math.floor(y + this.xOffset + this.yOffset);\n          r = g / 2 - .5;\n          this.from = a;\n          this.to = d;\n          l ? (this.scrollbarGroup[v]({\n            translateY: m\n          }), this.scrollbar[v]({\n            height: g\n          }), this.scrollbarRifles[v]({\n            translateY: r\n          }), this.scrollbarTop = m, this.scrollbarLeft = 0) : (this.scrollbarGroup[v]({\n            translateX: m\n          }), this.scrollbar[v]({\n            width: g\n          }), this.scrollbarRifles[v]({\n            translateX: r\n          }), this.scrollbarLeft = m, this.scrollbarTop = 0);\n          12 >= g ? this.scrollbarRifles.hide() : this.scrollbarRifles.show();\n          !1 === k.showFull && (0 >= a && 1 <= d ? this.group.hide() : this.group.show());\n          this.rendered = !0;\n        }\n      };\n\n      a.prototype.shouldUpdateExtremes = function (a) {\n        return k(this.options.liveRedraw, v.svg && !v.isTouchDevice && !this.chart.boosted) || \"mouseup\" === a || \"touchend\" === a || !b(a);\n      };\n\n      a.prototype.trackClick = function (a) {\n        var b = this.chart.pointer.normalize(a),\n            k = this.to - this.from,\n            l = this.y + this.scrollbarTop,\n            m = this.x + this.scrollbarLeft;\n        this.options.vertical && b.chartY > l || !this.options.vertical && b.chartX > m ? this.updatePosition(this.from + k, this.to + k) : this.updatePosition(this.from - k, this.to - k);\n        d(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: a\n        });\n      };\n\n      a.prototype.update = function (a) {\n        this.destroy();\n        this.init(this.chart.renderer, C(!0, this.options, a), this.chart);\n      };\n\n      a.prototype.updatePosition = function (a, b) {\n        1 < b && (a = t(1 - t(b - a)), b = 1);\n        0 > a && (b = t(b - a), a = 0);\n        this.from = a;\n        this.to = b;\n      };\n\n      a.defaultOptions = l;\n      return a;\n    }();\n\n    r.scrollbar = C(!0, a.defaultOptions, r.scrollbar);\n    return a;\n  });\n  J(a, \"Core/Axis/NavigatorAxis.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, v) {\n    var A = a.isTouchDevice,\n        l = v.addEvent,\n        y = v.correctFloat,\n        r = v.defined,\n        D = v.isNumber,\n        t = v.pick,\n        b = function () {\n      function a(a) {\n        this.axis = a;\n      }\n\n      a.prototype.destroy = function () {\n        this.axis = void 0;\n      };\n\n      a.prototype.toFixedRange = function (a, b, k, l) {\n        var d = this.axis,\n            m = d.chart;\n        m = m && m.fixedRange;\n        var v = (d.pointRange || 0) / 2;\n        a = t(k, d.translate(a, !0, !d.horiz));\n        b = t(l, d.translate(b, !0, !d.horiz));\n        d = m && (b - a) / m;\n        r(k) || (a = y(a + v));\n        r(l) || (b = y(b - v));\n        .7 < d && 1.3 > d && (l ? a = b - m : b = a + m);\n        D(a) && D(b) || (a = b = void 0);\n        return {\n          min: a,\n          max: b\n        };\n      };\n\n      return a;\n    }();\n\n    return function () {\n      function a() {}\n\n      a.compose = function (a) {\n        a.keepProps.push(\"navigatorAxis\");\n        l(a, \"init\", function () {\n          this.navigatorAxis || (this.navigatorAxis = new b(this));\n        });\n        l(a, \"zoom\", function (a) {\n          var b = this.chart.options,\n              d = b.navigator,\n              l = this.navigatorAxis,\n              m = b.chart.zooming.pinchType,\n              t = b.rangeSelector;\n          b = b.chart.zooming.type;\n          this.isXAxis && (d && d.enabled || t && t.enabled) && (\"y\" === b ? a.zoomed = !1 : (!A && \"xy\" === b || A && \"xy\" === m) && this.options.range && (d = l.previousZoom, r(a.newMin) ? l.previousZoom = [this.min, this.max] : d && (a.newMin = d[0], a.newMax = d[1], l.previousZoom = void 0)));\n          \"undefined\" !== typeof a.zoomed && a.preventDefault();\n        });\n      };\n\n      a.AdditionsClass = b;\n      return a;\n    }();\n  });\n  J(a, \"Core/Navigator.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/NavigatorAxis.js\"], a[\"Core/DefaultOptions.js\"], a[\"Core/Renderer/RendererRegistry.js\"], a[\"Core/Scrollbar.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, v, A, l, y, r, D, t, b, m, d) {\n    A = A.parse;\n\n    var C = l.hasTouch,\n        k = l.isTouchDevice,\n        K = r.defaultOptions,\n        E = d.addEvent,\n        L = d.clamp,\n        H = d.correctFloat,\n        q = d.defined,\n        J = d.destroyObjectProperties,\n        N = d.erase,\n        F = d.extend,\n        M = d.find,\n        g = d.isArray,\n        O = d.isNumber,\n        x = d.merge,\n        I = d.pick,\n        f = d.removeEvent,\n        e = d.splat,\n        c = function c(_c) {\n      for (var h = [], a = 1; a < arguments.length; a++) {\n        h[a - 1] = arguments[a];\n      }\n\n      h = [].filter.call(h, O);\n      if (h.length) return Math[_c].apply(0, h);\n    };\n\n    r = \"undefined\" === typeof m.seriesTypes.areaspline ? \"line\" : \"areaspline\";\n    F(K, {\n      navigator: {\n        height: 40,\n        margin: 25,\n        maskInside: !0,\n        handles: {\n          width: 7,\n          height: 15,\n          symbols: [\"navigator-handle\", \"navigator-handle\"],\n          enabled: !0,\n          lineWidth: 1,\n          backgroundColor: \"#f2f2f2\",\n          borderColor: \"#999999\"\n        },\n        maskFill: A(\"#6685c2\").setOpacity(.3).get(),\n        outlineColor: \"#cccccc\",\n        outlineWidth: 1,\n        series: {\n          type: r,\n          fillOpacity: .05,\n          lineWidth: 1,\n          compare: null,\n          dataGrouping: {\n            approximation: \"average\",\n            enabled: !0,\n            groupPixelWidth: 2,\n            firstAnchor: \"firstPoint\",\n            anchor: \"middle\",\n            lastAnchor: \"lastPoint\",\n            units: [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2, 3, 4]], [\"week\", [1, 2, 3]], [\"month\", [1, 3, 6]], [\"year\", null]]\n          },\n          dataLabels: {\n            enabled: !1,\n            zIndex: 2\n          },\n          id: \"highcharts-navigator-series\",\n          className: \"highcharts-navigator-series\",\n          lineColor: null,\n          marker: {\n            enabled: !1\n          },\n          threshold: null\n        },\n        xAxis: {\n          overscroll: 0,\n          className: \"highcharts-navigator-xaxis\",\n          tickLength: 0,\n          lineWidth: 0,\n          gridLineColor: \"#e6e6e6\",\n          gridLineWidth: 1,\n          tickPixelInterval: 200,\n          labels: {\n            align: \"left\",\n            style: {\n              color: \"#999999\"\n            },\n            x: 3,\n            y: -4\n          },\n          crosshair: !1\n        },\n        yAxis: {\n          className: \"highcharts-navigator-yaxis\",\n          gridLineWidth: 0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: .1,\n          maxPadding: .1,\n          labels: {\n            enabled: !1\n          },\n          crosshair: !1,\n          title: {\n            text: null\n          },\n          tickLength: 0,\n          tickWidth: 0\n        }\n      }\n    });\n\n    D.getRendererType().prototype.symbols[\"navigator-handle\"] = function (a, h, c, b, e) {\n      a = (e && e.width || 0) / 2;\n      h = Math.round(a / 3) + .5;\n      e = e && e.height || 0;\n      return [[\"M\", -a - 1, .5], [\"L\", a, .5], [\"L\", a, e + .5], [\"L\", -a - 1, e + .5], [\"L\", -a - 1, .5], [\"M\", -h, 4], [\"L\", -h, e - 3], [\"M\", h - 1, 4], [\"L\", h - 1, e - 3]];\n    };\n\n    var p = function () {\n      function b(h) {\n        this.zoomedMin = this.zoomedMax = this.yAxis = this.xAxis = this.top = this.size = this.shades = this.rendered = this.range = this.outlineHeight = this.outline = this.opposite = this.navigatorSize = this.navigatorSeries = this.navigatorOptions = this.navigatorGroup = this.navigatorEnabled = this.left = this.height = this.handles = this.chart = this.baseSeries = void 0;\n        this.init(h);\n      }\n\n      b.prototype.drawHandle = function (h, a, c, b) {\n        var e = this.navigatorOptions.handles.height;\n        this.handles[a][b](c ? {\n          translateX: Math.round(this.left + this.height / 2),\n          translateY: Math.round(this.top + parseInt(h, 10) + .5 - e)\n        } : {\n          translateX: Math.round(this.left + parseInt(h, 10)),\n          translateY: Math.round(this.top + this.height / 2 - e / 2 - 1)\n        });\n      };\n\n      b.prototype.drawOutline = function (h, a, c, b) {\n        var e = this.navigatorOptions.maskInside,\n            u = this.outline.strokeWidth(),\n            d = u / 2,\n            w = u % 2 / 2;\n        u = this.outlineHeight;\n        var n = this.scrollbarHeight || 0,\n            p = this.size,\n            f = this.left - n,\n            g = this.top;\n        c ? (f -= d, c = g + a + w, a = g + h + w, w = [[\"M\", f + u, g - n - w], [\"L\", f + u, c], [\"L\", f, c], [\"L\", f, a], [\"L\", f + u, a], [\"L\", f + u, g + p + n]], e && w.push([\"M\", f + u, c - d], [\"L\", f + u, a + d])) : (h += f + n - w, a += f + n - w, g += d, w = [[\"M\", f, g], [\"L\", h, g], [\"L\", h, g + u], [\"L\", a, g + u], [\"L\", a, g], [\"L\", f + p + 2 * n, g]], e && w.push([\"M\", h - d, g], [\"L\", a + d, g]));\n        this.outline[b]({\n          d: w\n        });\n      };\n\n      b.prototype.drawMasks = function (h, a, c, b) {\n        var e = this.left,\n            u = this.top,\n            d = this.height;\n\n        if (c) {\n          var w = [e, e, e];\n          var n = [u, u + h, u + a];\n          var p = [d, d, d];\n          var f = [h, a - h, this.size - a];\n        } else w = [e, e + h, e + a], n = [u, u, u], p = [h, a - h, this.size - a], f = [d, d, d];\n\n        this.shades.forEach(function (h, a) {\n          h[b]({\n            x: w[a],\n            y: n[a],\n            width: p[a],\n            height: f[a]\n          });\n        });\n      };\n\n      b.prototype.renderElements = function () {\n        var h = this,\n            a = h.navigatorOptions,\n            c = a.maskInside,\n            b = h.chart,\n            e = b.renderer,\n            d,\n            n = {\n          cursor: b.inverted ? \"ns-resize\" : \"ew-resize\"\n        };\n        h.navigatorGroup = d = e.g(\"navigator\").attr({\n          zIndex: 8,\n          visibility: \"hidden\"\n        }).add();\n        [!c, c, !c].forEach(function (c, u) {\n          var w = e.rect().addClass(\"highcharts-navigator-mask\" + (1 === u ? \"-inside\" : \"-outside\")).add(d);\n          b.styledMode || (w.attr({\n            fill: c ? a.maskFill : \"rgba(0,0,0,0)\"\n          }), 1 === u && w.css(n));\n          h.shades[u] = w;\n        });\n        h.outline = e.path().addClass(\"highcharts-navigator-outline\").add(d);\n        b.styledMode || h.outline.attr({\n          \"stroke-width\": a.outlineWidth,\n          stroke: a.outlineColor\n        });\n        a.handles.enabled && [0, 1].forEach(function (c) {\n          a.handles.inverted = b.inverted;\n          h.handles[c] = e.symbol(a.handles.symbols[c], -a.handles.width / 2 - 1, 0, a.handles.width, a.handles.height, a.handles);\n          h.handles[c].attr({\n            zIndex: 7 - c\n          }).addClass(\"highcharts-navigator-handle highcharts-navigator-handle-\" + [\"left\", \"right\"][c]).add(d);\n\n          if (!b.styledMode) {\n            var u = a.handles;\n            h.handles[c].attr({\n              fill: u.backgroundColor,\n              stroke: u.borderColor,\n              \"stroke-width\": u.lineWidth\n            }).css(n);\n          }\n        });\n      };\n\n      b.prototype.update = function (a) {\n        (this.series || []).forEach(function (a) {\n          a.baseSeries && delete a.baseSeries.navigatorSeries;\n        });\n        this.destroy();\n        x(!0, this.chart.options.navigator, this.options, a);\n        this.init(this.chart);\n      };\n\n      b.prototype.render = function (a, c, b, e) {\n        var h = this.chart,\n            u = this.scrollbarHeight,\n            d,\n            n = this.xAxis,\n            w = n.pointRange || 0;\n        var p = n.navigatorAxis.fake ? h.xAxis[0] : n;\n        var f = this.navigatorEnabled,\n            g,\n            k = this.rendered;\n        var l = h.inverted;\n        var m = h.xAxis[0].minRange,\n            P = h.xAxis[0].options.maxRange;\n\n        if (!this.hasDragged || q(b)) {\n          a = H(a - w / 2);\n          c = H(c + w / 2);\n          if (!O(a) || !O(c)) if (k) b = 0, e = I(n.width, p.width);else return;\n          this.left = I(n.left, h.plotLeft + u + (l ? h.plotWidth : 0));\n          this.size = g = d = I(n.len, (l ? h.plotHeight : h.plotWidth) - 2 * u);\n          h = l ? u : d + 2 * u;\n          b = I(b, n.toPixels(a, !0));\n          e = I(e, n.toPixels(c, !0));\n          O(b) && Infinity !== Math.abs(b) || (b = 0, e = h);\n          a = n.toValue(b, !0);\n          c = n.toValue(e, !0);\n          var x = Math.abs(H(c - a));\n          x < m ? this.grabbedLeft ? b = n.toPixels(c - m - w, !0) : this.grabbedRight && (e = n.toPixels(a + m + w, !0)) : q(P) && H(x - w) > P && (this.grabbedLeft ? b = n.toPixels(c - P - w, !0) : this.grabbedRight && (e = n.toPixels(a + P + w, !0)));\n          this.zoomedMax = L(Math.max(b, e), 0, g);\n          this.zoomedMin = L(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(b, e), 0, g);\n          this.range = this.zoomedMax - this.zoomedMin;\n          g = Math.round(this.zoomedMax);\n          b = Math.round(this.zoomedMin);\n          f && (this.navigatorGroup.attr({\n            visibility: \"inherit\"\n          }), k = k && !this.hasDragged ? \"animate\" : \"attr\", this.drawMasks(b, g, l, k), this.drawOutline(b, g, l, k), this.navigatorOptions.handles.enabled && (this.drawHandle(b, 0, l, k), this.drawHandle(g, 1, l, k)));\n          this.scrollbar && (l ? (l = this.top - u, p = this.left - u + (f || !p.opposite ? 0 : (p.titleOffset || 0) + p.axisTitleMargin), u = d + 2 * u) : (l = this.top + (f ? this.height : -u), p = this.left - u), this.scrollbar.position(p, l, h, u), this.scrollbar.setRange(this.zoomedMin / (d || 1), this.zoomedMax / (d || 1)));\n          this.rendered = !0;\n        }\n      };\n\n      b.prototype.addMouseEvents = function () {\n        var a = this,\n            c = a.chart,\n            b = c.container,\n            e = [],\n            d,\n            n;\n\n        a.mouseMoveHandler = d = function d(c) {\n          a.onMouseMove(c);\n        };\n\n        a.mouseUpHandler = n = function n(c) {\n          a.onMouseUp(c);\n        };\n\n        e = a.getPartsEvents(\"mousedown\");\n        e.push(E(c.renderTo, \"mousemove\", d), E(b.ownerDocument, \"mouseup\", n));\n        C && (e.push(E(c.renderTo, \"touchmove\", d), E(b.ownerDocument, \"touchend\", n)), e.concat(a.getPartsEvents(\"touchstart\")));\n        a.eventsToUnbind = e;\n        a.series && a.series[0] && e.push(E(a.series[0].xAxis, \"foundExtremes\", function () {\n          c.navigator.modifyNavigatorAxisExtremes();\n        }));\n      };\n\n      b.prototype.getPartsEvents = function (a) {\n        var c = this,\n            h = [];\n        [\"shades\", \"handles\"].forEach(function (b) {\n          c[b].forEach(function (e, u) {\n            h.push(E(e.element, a, function (a) {\n              c[b + \"Mousedown\"](a, u);\n            }));\n          });\n        });\n        return h;\n      };\n\n      b.prototype.shadesMousedown = function (a, c) {\n        a = this.chart.pointer.normalize(a);\n        var b = this.chart,\n            h = this.xAxis,\n            e = this.zoomedMin,\n            u = this.left,\n            d = this.size,\n            n = this.range,\n            p = a.chartX;\n        b.inverted && (p = a.chartY, u = this.top);\n        if (1 === c) this.grabbedCenter = p, this.fixedWidth = n, this.dragOffset = p - e;else {\n          a = p - u - n / 2;\n          if (0 === c) a = Math.max(0, a);else if (2 === c && a + n >= d) if (a = d - n, this.reversedExtremes) {\n            a -= n;\n            var f = this.getUnionExtremes().dataMin;\n          } else var g = this.getUnionExtremes().dataMax;\n          a !== e && (this.fixedWidth = n, c = h.navigatorAxis.toFixedRange(a, a + n, f, g), q(c.min) && b.xAxis[0].setExtremes(Math.min(c.min, c.max), Math.max(c.min, c.max), !0, null, {\n            trigger: \"navigator\"\n          }));\n        }\n      };\n\n      b.prototype.handlesMousedown = function (a, c) {\n        this.chart.pointer.normalize(a);\n        a = this.chart;\n        var b = a.xAxis[0],\n            h = this.reversedExtremes;\n        0 === c ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = h ? b.min : b.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = h ? b.max : b.min);\n        a.fixedRange = null;\n      };\n\n      b.prototype.onMouseMove = function (a) {\n        var c = this,\n            b = c.chart,\n            h = c.left,\n            e = c.navigatorSize,\n            d = c.range,\n            n = c.dragOffset,\n            p = b.inverted;\n        a.touches && 0 === a.touches[0].pageX || (a = b.pointer.normalize(a), b = a.chartX, p && (h = c.top, b = a.chartY), c.grabbedLeft ? (c.hasDragged = !0, c.render(0, 0, b - h, c.otherHandlePos)) : c.grabbedRight ? (c.hasDragged = !0, c.render(0, 0, c.otherHandlePos, b - h)) : c.grabbedCenter && (c.hasDragged = !0, b < n ? b = n : b > e + n - d && (b = e + n - d), c.render(0, 0, b - n, b - n + d)), c.hasDragged && c.scrollbar && I(c.scrollbar.options.liveRedraw, l.svg && !k && !this.chart.boosted) && (a.DOMType = a.type, setTimeout(function () {\n          c.onMouseUp(a);\n        }, 0)));\n      };\n\n      b.prototype.onMouseUp = function (a) {\n        var c = this.chart,\n            b = this.xAxis,\n            h = this.scrollbar,\n            e = a.DOMEvent || a,\n            n = c.inverted,\n            d = this.rendered && !this.hasDragged ? \"animate\" : \"attr\";\n\n        if (this.hasDragged && (!h || !h.hasDragged) || \"scrollbar\" === a.trigger) {\n          h = this.getUnionExtremes();\n          if (this.zoomedMin === this.otherHandlePos) var p = this.fixedExtreme;else if (this.zoomedMax === this.otherHandlePos) var f = this.fixedExtreme;\n          this.zoomedMax === this.size && (f = this.reversedExtremes ? h.dataMin : h.dataMax);\n          0 === this.zoomedMin && (p = this.reversedExtremes ? h.dataMax : h.dataMin);\n          b = b.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, p, f);\n          q(b.min) && c.xAxis[0].setExtremes(Math.min(b.min, b.max), Math.max(b.min, b.max), !0, this.hasDragged ? !1 : null, {\n            trigger: \"navigator\",\n            triggerOp: \"navigator-drag\",\n            DOMEvent: e\n          });\n        }\n\n        \"mousemove\" !== a.DOMType && \"touchmove\" !== a.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);\n        this.navigatorEnabled && O(this.zoomedMin) && O(this.zoomedMax) && (c = Math.round(this.zoomedMin), a = Math.round(this.zoomedMax), this.shades && this.drawMasks(c, a, n, d), this.outline && this.drawOutline(c, a, n, d), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(c, 0, n, d), this.drawHandle(a, 1, n, d)));\n      };\n\n      b.prototype.removeEvents = function () {\n        this.eventsToUnbind && (this.eventsToUnbind.forEach(function (a) {\n          a();\n        }), this.eventsToUnbind = void 0);\n        this.removeBaseSeriesEvents();\n      };\n\n      b.prototype.removeBaseSeriesEvents = function () {\n        var a = this.baseSeries || [];\n        this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && a.forEach(function (a) {\n          f(a, \"updatedData\", this.updatedDataHandler);\n        }, this), a[0].xAxis && f(a[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n      };\n\n      b.prototype.init = function (b) {\n        var h = b.options,\n            e = h.navigator,\n            n = e.enabled,\n            d = h.scrollbar,\n            p = d.enabled;\n        h = n ? e.height : 0;\n        var f = p ? d.height : 0;\n        this.handles = [];\n        this.shades = [];\n        this.chart = b;\n        this.setBaseSeries();\n        this.height = h;\n        this.scrollbarHeight = f;\n        this.scrollbarEnabled = p;\n        this.navigatorEnabled = n;\n        this.navigatorOptions = e;\n        this.scrollbarOptions = d;\n        this.outlineHeight = h + f;\n        this.opposite = I(e.opposite, !(n || !b.inverted));\n        var g = this;\n        n = g.baseSeries;\n        d = b.xAxis.length;\n        p = b.yAxis.length;\n        var k = n && n[0] && n[0].xAxis || b.xAxis[0] || {\n          options: {}\n        };\n        b.isDirtyBox = !0;\n        g.navigatorEnabled ? (g.xAxis = new a(b, x({\n          breaks: k.options.breaks,\n          ordinal: k.options.ordinal\n        }, e.xAxis, {\n          id: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          isX: !0,\n          type: \"datetime\",\n          index: d,\n          isInternal: !0,\n          offset: 0,\n          keepOrdinalPadding: !0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: 0,\n          maxPadding: 0,\n          zoomEnabled: !1\n        }, b.inverted ? {\n          offsets: [f, 0, -f, 0],\n          width: h\n        } : {\n          offsets: [0, -f, 0, f],\n          height: h\n        })), g.yAxis = new a(b, x(e.yAxis, {\n          id: \"navigator-y-axis\",\n          alignTicks: !1,\n          offset: 0,\n          index: p,\n          isInternal: !0,\n          reversed: I(e.yAxis && e.yAxis.reversed, b.yAxis[0] && b.yAxis[0].reversed, !1),\n          zoomEnabled: !1\n        }, b.inverted ? {\n          width: h\n        } : {\n          height: h\n        })), n || e.series.data ? g.updateNavigatorSeries(!1) : 0 === b.series.length && (g.unbindRedraw = E(b, \"beforeRedraw\", function () {\n          0 < b.series.length && !g.series && (g.setBaseSeries(), g.unbindRedraw());\n        })), g.reversedExtremes = b.inverted && !g.xAxis.reversed || !b.inverted && g.xAxis.reversed, g.renderElements(), g.addMouseEvents()) : (g.xAxis = {\n          chart: b,\n          navigatorAxis: {\n            fake: !0\n          },\n          translate: function translate(a, h) {\n            var e = b.xAxis[0],\n                n = e.getExtremes(),\n                d = e.len - 2 * f,\n                u = c(\"min\", e.options.min, n.dataMin);\n            e = c(\"max\", e.options.max, n.dataMax) - u;\n            return h ? a * e / d + u : d * (a - u) / e;\n          },\n          toPixels: function toPixels(a) {\n            return this.translate(a);\n          },\n          toValue: function toValue(a) {\n            return this.translate(a, !0);\n          }\n        }, g.xAxis.navigatorAxis.axis = g.xAxis, g.xAxis.navigatorAxis.toFixedRange = y.AdditionsClass.prototype.toFixedRange.bind(g.xAxis.navigatorAxis));\n        b.options.scrollbar.enabled && (b.scrollbar = g.scrollbar = new t(b.renderer, x(b.options.scrollbar, {\n          margin: g.navigatorEnabled ? 0 : 10,\n          vertical: b.inverted\n        }), b), E(g.scrollbar, \"changed\", function (a) {\n          var c = g.size,\n              b = c * this.to;\n          c *= this.from;\n          g.hasDragged = g.scrollbar.hasDragged;\n          g.render(0, 0, c, b);\n          this.shouldUpdateExtremes(a.DOMType) && setTimeout(function () {\n            g.onMouseUp(a);\n          });\n        }));\n        g.addBaseSeriesEvents();\n        g.addChartEvents();\n      };\n\n      b.prototype.getUnionExtremes = function (a) {\n        var b = this.chart.xAxis[0],\n            h = this.xAxis,\n            e = h.options,\n            n = b.options,\n            d;\n        a && null === b.dataMin || (d = {\n          dataMin: I(e && e.min, c(\"min\", n.min, b.dataMin, h.dataMin, h.min)),\n          dataMax: I(e && e.max, c(\"max\", n.max, b.dataMax, h.dataMax, h.max))\n        });\n        return d;\n      };\n\n      b.prototype.setBaseSeries = function (a, c) {\n        var b = this.chart,\n            h = this.baseSeries = [];\n        a = a || b.options && b.options.navigator.baseSeries || (b.series.length ? M(b.series, function (a) {\n          return !a.options.isInternal;\n        }).index : 0);\n        (b.series || []).forEach(function (c, b) {\n          c.options.isInternal || !c.options.showInNavigator && (b !== a && c.options.id !== a || !1 === c.options.showInNavigator) || h.push(c);\n        });\n        this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, c);\n      };\n\n      b.prototype.updateNavigatorSeries = function (a, c) {\n        var b = this,\n            h = b.chart,\n            n = b.baseSeries,\n            d,\n            u,\n            p = b.navigatorOptions.series,\n            k,\n            l = {\n          enableMouseTracking: !1,\n          index: null,\n          linkedTo: null,\n          group: \"nav\",\n          padXAxis: !1,\n          xAxis: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          showInLegend: !1,\n          stacking: void 0,\n          isInternal: !0,\n          states: {\n            inactive: {\n              opacity: 1\n            }\n          }\n        },\n            m = b.series = (b.series || []).filter(function (a) {\n          var c = a.baseSeries;\n          return 0 > n.indexOf(c) ? (c && (f(c, \"updatedData\", b.updatedDataHandler), delete c.navigatorSeries), a.chart && a.destroy(), !1) : !0;\n        });\n        n && n.length && n.forEach(function (a) {\n          var f = a.navigatorSeries,\n              w = F({\n            color: a.color,\n            visible: a.visible\n          }, g(p) ? K.navigator.series : p);\n          f && !1 === b.navigatorOptions.adaptToUpdatedData || (l.name = \"Navigator \" + n.length, d = a.options || {}, k = d.navigatorOptions || {}, w.dataLabels = e(w.dataLabels), u = x(d, l, w, k), u.pointRange = I(w.pointRange, k.pointRange, K.plotOptions[u.type || \"line\"].pointRange), w = k.data || w.data, b.hasNavigatorData = b.hasNavigatorData || !!w, u.data = w || d.data && d.data.slice(0), f && f.options ? f.update(u, c) : (a.navigatorSeries = h.initSeries(u), a.navigatorSeries.baseSeries = a, m.push(a.navigatorSeries)));\n        });\n        if (p.data && (!n || !n.length) || g(p)) b.hasNavigatorData = !1, p = e(p), p.forEach(function (a, c) {\n          l.name = \"Navigator \" + (m.length + 1);\n          u = x(K.navigator.series, {\n            color: h.series[c] && !h.series[c].options.isInternal && h.series[c].color || h.options.colors[c] || h.options.colors[0]\n          }, l, a);\n          u.data = a.data;\n          u.data && (b.hasNavigatorData = !0, m.push(h.initSeries(u)));\n        });\n        a && this.addBaseSeriesEvents();\n      };\n\n      b.prototype.addBaseSeriesEvents = function () {\n        var a = this,\n            c = a.baseSeries || [];\n        c[0] && c[0].xAxis && c[0].eventsToUnbind.push(E(c[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n        c.forEach(function (c) {\n          c.eventsToUnbind.push(E(c, \"show\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);\n          }));\n          c.eventsToUnbind.push(E(c, \"hide\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);\n          }));\n          !1 !== this.navigatorOptions.adaptToUpdatedData && c.xAxis && c.eventsToUnbind.push(E(c, \"updatedData\", this.updatedDataHandler));\n          c.eventsToUnbind.push(E(c, \"remove\", function () {\n            this.navigatorSeries && (N(a.series, this.navigatorSeries), q(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);\n          }));\n        }, this);\n      };\n\n      b.prototype.getBaseSeriesMin = function (a) {\n        return this.baseSeries.reduce(function (a, c) {\n          return Math.min(a, c.xData && c.xData.length ? c.xData[0] : a);\n        }, a);\n      };\n\n      b.prototype.modifyNavigatorAxisExtremes = function () {\n        var a = this.xAxis,\n            c;\n        \"undefined\" !== typeof a.getExtremes && (!(c = this.getUnionExtremes(!0)) || c.dataMin === a.min && c.dataMax === a.max || (a.min = c.dataMin, a.max = c.dataMax));\n      };\n\n      b.prototype.modifyBaseAxisExtremes = function () {\n        var a = this.chart.navigator,\n            c = this.getExtremes(),\n            b = c.dataMin,\n            e = c.dataMax;\n        c = c.max - c.min;\n        var n = a.stickToMin,\n            d = a.stickToMax,\n            p = I(this.options.overscroll, 0),\n            f = a.series && a.series[0],\n            g = !!this.setExtremes;\n\n        if (!this.eventArgs || \"rangeSelectorButton\" !== this.eventArgs.trigger) {\n          if (n) {\n            var k = b;\n            var l = k + c;\n          }\n\n          d && (l = e + p, n || (k = Math.max(b, l - c, a.getBaseSeriesMin(f && f.xData ? f.xData[0] : -Number.MAX_VALUE))));\n          g && (n || d) && O(k) && (this.min = this.userMin = k, this.max = this.userMax = l);\n        }\n\n        a.stickToMin = a.stickToMax = null;\n      };\n\n      b.prototype.updatedDataHandler = function () {\n        var a = this.chart.navigator,\n            c = this.navigatorSeries;\n        a.stickToMax = I(this.chart.options.navigator && this.chart.options.navigator.stickToMax, a.reversedExtremes ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >= Math.round(a.size));\n        a.stickToMin = a.shouldStickToMin(this, a);\n        c && !a.hasNavigatorData && (c.options.pointStart = this.xData[0], c.setData(this.options.data, !1, null, !1));\n      };\n\n      b.prototype.shouldStickToMin = function (a, c) {\n        c = c.getBaseSeriesMin(a.xData[0]);\n        var b = a.xAxis;\n        a = b.max;\n        var h = b.min;\n        b = b.options.range;\n        return O(a) && O(h) ? b && 0 < a - c ? a - c < b : h <= c : !1;\n      };\n\n      b.prototype.addChartEvents = function () {\n        this.eventsToUnbind || (this.eventsToUnbind = []);\n        this.eventsToUnbind.push(E(this.chart, \"redraw\", function () {\n          var a = this.navigator,\n              c = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || this.xAxis[0]);\n          c && a.render(c.min, c.max);\n        }), E(this.chart, \"getMargins\", function () {\n          var a = this.navigator,\n              c = a.opposite ? \"plotTop\" : \"marginBottom\";\n          this.inverted && (c = a.opposite ? \"marginRight\" : \"plotLeft\");\n          this[c] = (this[c] || 0) + (a.navigatorEnabled || !this.inverted ? a.outlineHeight : 0) + a.navigatorOptions.margin;\n        }));\n      };\n\n      b.prototype.destroy = function () {\n        this.removeEvents();\n        this.xAxis && (N(this.chart.xAxis, this.xAxis), N(this.chart.axes, this.xAxis));\n        this.yAxis && (N(this.chart.yAxis, this.yAxis), N(this.chart.axes, this.yAxis));\n        (this.series || []).forEach(function (a) {\n          a.destroy && a.destroy();\n        });\n        \"series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered\".split(\" \").forEach(function (a) {\n          this[a] && this[a].destroy && this[a].destroy();\n          this[a] = null;\n        }, this);\n        [this.handles].forEach(function (a) {\n          J(a);\n        }, this);\n      };\n\n      return b;\n    }();\n\n    l.Navigator || (l.Navigator = p, y.compose(a), E(v, \"beforeShowResetZoom\", function () {\n      var a = this.options,\n          c = a.navigator,\n          b = a.rangeSelector;\n      if ((c && c.enabled || b && b.enabled) && (!k && \"x\" === a.chart.zooming.type || k && \"x\" === a.chart.zooming.pinchType)) return !1;\n    }), E(v, \"beforeRender\", function () {\n      var a = this.options;\n      if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new p(this);\n    }), E(v, \"afterSetChartSize\", function () {\n      var a = this.legend,\n          c = this.navigator;\n\n      if (c) {\n        var b = a && a.options;\n        var e = c.xAxis;\n        var d = c.yAxis;\n        var p = c.scrollbarHeight;\n        this.inverted ? (c.left = c.opposite ? this.chartWidth - p - c.height : this.spacing[3] + p, c.top = this.plotTop + p) : (c.left = I(e.left, this.plotLeft + p), c.top = c.navigatorOptions.top || this.chartHeight - c.height - p - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (b && \"bottom\" === b.verticalAlign && \"proximate\" !== b.layout && b.enabled && !b.floating ? a.legendHeight + I(b.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0));\n        e && d && (this.inverted ? e.options.left = d.options.left = c.left : e.options.top = d.options.top = c.top, e.setAxisSize(), d.setAxisSize());\n      }\n    }), E(v, \"update\", function (a) {\n      var c = a.options.navigator || {},\n          b = a.options.scrollbar || {};\n      this.navigator || this.scroller || !c.enabled && !b.enabled || (x(!0, this.options.navigator, c), x(!0, this.options.scrollbar, b), delete a.options.navigator, delete a.options.scrollbar);\n    }), E(v, \"afterUpdate\", function (a) {\n      this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new p(this), I(a.redraw, !0) && this.redraw(a.animation));\n    }), E(v, \"afterAddSeries\", function () {\n      this.navigator && this.navigator.setBaseSeries(null, !1);\n    }), E(b, \"afterUpdate\", function () {\n      this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);\n    }), v.prototype.callbacks.push(function (a) {\n      var c = a.navigator;\n      c && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), c.render(a.min, a.max));\n    }));\n    l.Navigator = p;\n    return l.Navigator;\n  });\n  J(a, \"Extensions/RangeSelector.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Globals.js\"], a[\"Core/DefaultOptions.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, v, A, l, y, r) {\n    function D(a) {\n      if (-1 !== a.indexOf(\"%L\")) return \"text\";\n      var c = \"aAdewbBmoyY\".split(\"\").some(function (c) {\n        return -1 !== a.indexOf(\"%\" + c);\n      }),\n          b = \"HkIlMS\".split(\"\").some(function (c) {\n        return -1 !== a.indexOf(\"%\" + c);\n      });\n      return c && b ? \"datetime-local\" : c ? \"date\" : b ? \"time\" : \"text\";\n    }\n\n    var t = l.defaultOptions,\n        b = r.addEvent,\n        m = r.createElement,\n        d = r.css,\n        C = r.defined,\n        k = r.destroyObjectProperties,\n        K = r.discardElement,\n        E = r.extend,\n        L = r.find,\n        H = r.fireEvent,\n        q = r.isNumber,\n        J = r.merge,\n        N = r.objectEach,\n        F = r.pad,\n        M = r.pick,\n        g = r.pInt,\n        O = r.splat;\n    E(t, {\n      rangeSelector: {\n        allButtonsEnabled: !1,\n        buttons: void 0,\n        buttonSpacing: 5,\n        dropdown: \"responsive\",\n        enabled: void 0,\n        verticalAlign: \"top\",\n        buttonTheme: {\n          width: 28,\n          height: 18,\n          padding: 2,\n          zIndex: 7\n        },\n        floating: !1,\n        x: 0,\n        y: 0,\n        height: void 0,\n        inputBoxBorderColor: \"none\",\n        inputBoxHeight: 17,\n        inputBoxWidth: void 0,\n        inputDateFormat: \"%b %e, %Y\",\n        inputDateParser: void 0,\n        inputEditDateFormat: \"%Y-%m-%d\",\n        inputEnabled: !0,\n        inputPosition: {\n          align: \"right\",\n          x: 0,\n          y: 0\n        },\n        inputSpacing: 5,\n        selected: void 0,\n        buttonPosition: {\n          align: \"left\",\n          x: 0,\n          y: 0\n        },\n        inputStyle: {\n          color: \"#335cad\",\n          cursor: \"pointer\"\n        },\n        labelStyle: {\n          color: \"#666666\"\n        }\n      }\n    });\n    E(t.lang, {\n      rangeSelectorZoom: \"Zoom\",\n      rangeSelectorFrom: \"\",\n      rangeSelectorTo: \"\\u2192\"\n    });\n\n    var x = function () {\n      function e(a) {\n        this.buttons = void 0;\n        this.buttonOptions = e.prototype.defaultButtons;\n        this.initialButtonGroupWidth = 0;\n        this.options = void 0;\n        this.chart = a;\n        this.init(a);\n      }\n\n      e.prototype.clickButton = function (c, e) {\n        var d = this.chart,\n            h = this.buttonOptions[c],\n            p = d.xAxis[0],\n            f = d.scroller && d.scroller.getUnionExtremes() || p || {},\n            g = f.dataMin,\n            k = f.dataMax,\n            l = p && Math.round(Math.min(p.max, M(k, p.max))),\n            m = h.type;\n        f = h._range;\n        var x,\n            t = h.dataGrouping;\n        var r = !0;\n\n        if (null !== g && null !== k) {\n          d.fixedRange = f;\n          this.setSelected(c);\n          t && (this.forcedDataGrouping = !0, a.prototype.setDataGrouping.call(p || {\n            chart: this.chart\n          }, t, !1), this.frozenStates = h.preserveDataGrouping);\n          if (\"month\" === m || \"year\" === m) {\n            if (p) {\n              r = {\n                range: h,\n                max: l,\n                chart: d,\n                dataMin: g,\n                dataMax: k\n              };\n              var v = p.minFromRange.call(r);\n              q(r.newMax) && (l = r.newMax);\n              r = !1;\n            } else f = h;\n          } else if (f) v = Math.max(l - f, g), l = Math.min(v + f, k), r = !1;else if (\"ytd\" === m) {\n            if (p) {\n              if (\"undefined\" === typeof k || \"undefined\" === typeof g) g = Number.MAX_VALUE, k = Number.MIN_VALUE, d.series.forEach(function (a) {\n                if (a = a.xData) g = Math.min(a[0], g), k = Math.max(a[a.length - 1], k);\n              }), e = !1;\n              l = this.getYTDExtremes(k, g, d.time.useUTC);\n              v = x = l.min;\n              l = l.max;\n            } else {\n              this.deferredYTDClick = c;\n              return;\n            }\n          } else \"all\" === m && p && (d.navigator && d.navigator.baseSeries[0] && (d.navigator.baseSeries[0].xAxis.options.range = void 0), v = g, l = k);\n          r && h._offsetMin && C(v) && (v += h._offsetMin);\n          h._offsetMax && C(l) && (l += h._offsetMax);\n          this.dropdown && (this.dropdown.selectedIndex = c + 1);\n          if (p) p.setExtremes(v, l, M(e, !0), void 0, {\n            trigger: \"rangeSelectorButton\",\n            rangeSelectorButton: h\n          });else {\n            var y = O(d.options.xAxis)[0];\n            var I = y.range;\n            y.range = f;\n            var A = y.min;\n            y.min = x;\n            b(d, \"load\", function () {\n              y.range = I;\n              y.min = A;\n            });\n          }\n          H(this, \"afterBtnClick\");\n        }\n      };\n\n      e.prototype.setSelected = function (a) {\n        this.selected = this.options.selected = a;\n      };\n\n      e.prototype.init = function (a) {\n        var c = this,\n            e = a.options.rangeSelector,\n            h = e.buttons || c.defaultButtons.slice(),\n            d = e.selected,\n            f = function f() {\n          var a = c.minInput,\n              b = c.maxInput;\n          a && a.blur && H(a, \"blur\");\n          b && b.blur && H(b, \"blur\");\n        };\n\n        c.chart = a;\n        c.options = e;\n        c.buttons = [];\n        c.buttonOptions = h;\n        this.eventsToUnbind = [];\n        this.eventsToUnbind.push(b(a.container, \"mousedown\", f));\n        this.eventsToUnbind.push(b(a, \"resize\", f));\n        h.forEach(c.computeButtonRange);\n        \"undefined\" !== typeof d && h[d] && this.clickButton(d, !1);\n        this.eventsToUnbind.push(b(a, \"load\", function () {\n          a.xAxis && a.xAxis[0] && b(a.xAxis[0], \"setExtremes\", function (b) {\n            this.max - this.min !== a.fixedRange && \"rangeSelectorButton\" !== b.trigger && \"updatedData\" !== b.trigger && c.forcedDataGrouping && !c.frozenStates && this.setDataGrouping(!1, !1);\n          });\n        }));\n      };\n\n      e.prototype.updateButtonStates = function () {\n        var a = this,\n            b = this.chart,\n            e = this.dropdown,\n            h = b.xAxis[0],\n            d = Math.round(h.max - h.min),\n            f = !h.hasVisibleSeries,\n            g = b.scroller && b.scroller.getUnionExtremes() || h,\n            k = g.dataMin,\n            l = g.dataMax;\n        b = a.getYTDExtremes(l, k, b.time.useUTC);\n        var m = b.min,\n            x = b.max,\n            t = a.selected,\n            r = q(t),\n            v = a.options.allButtonsEnabled,\n            y = a.buttons;\n        a.buttonOptions.forEach(function (c, b) {\n          var n = c._range,\n              p = c.type,\n              g = c.count || 1,\n              u = y[b],\n              w = 0,\n              q = c._offsetMax - c._offsetMin;\n          c = b === t;\n          var z = n > l - k,\n              B = n < h.minRange,\n              G = !1,\n              P = !1;\n          n = n === d;\n          (\"month\" === p || \"year\" === p) && d + 36E5 >= 864E5 * {\n            month: 28,\n            year: 365\n          }[p] * g - q && d - 36E5 <= 864E5 * {\n            month: 31,\n            year: 366\n          }[p] * g + q ? n = !0 : \"ytd\" === p ? (n = x - m + q === d, G = !c) : \"all\" === p && (n = h.max - h.min >= l - k, P = !c && r && n);\n          p = !v && (z || B || P || f);\n          g = c && n || n && !r && !G || c && a.frozenStates;\n          p ? w = 3 : g && (r = !0, w = 2);\n          u.state !== w && (u.setState(w), e && (e.options[b + 1].disabled = p, 2 === w && (e.selectedIndex = b + 1)), 0 === w && t === b && a.setSelected());\n        });\n      };\n\n      e.prototype.computeButtonRange = function (a) {\n        var c = a.type,\n            b = a.count || 1,\n            e = {\n          millisecond: 1,\n          second: 1E3,\n          minute: 6E4,\n          hour: 36E5,\n          day: 864E5,\n          week: 6048E5\n        };\n        if (e[c]) a._range = e[c] * b;else if (\"month\" === c || \"year\" === c) a._range = 864E5 * {\n          month: 30,\n          year: 365\n        }[c] * b;\n        a._offsetMin = M(a.offsetMin, 0);\n        a._offsetMax = M(a.offsetMax, 0);\n        a._range += a._offsetMax - a._offsetMin;\n      };\n\n      e.prototype.getInputValue = function (a) {\n        a = \"min\" === a ? this.minInput : this.maxInput;\n        var c = this.chart.options.rangeSelector,\n            b = this.chart.time;\n        return a ? (\"text\" === a.type && c.inputDateParser || this.defaultInputDateParser)(a.value, b.useUTC, b) : 0;\n      };\n\n      e.prototype.setInputValue = function (a, b) {\n        var c = this.options,\n            e = this.chart.time,\n            d = \"min\" === a ? this.minInput : this.maxInput;\n        a = \"min\" === a ? this.minDateBox : this.maxDateBox;\n\n        if (d) {\n          var f = d.getAttribute(\"data-hc-time\");\n          f = C(f) ? Number(f) : void 0;\n          C(b) && (C(f) && d.setAttribute(\"data-hc-time-previous\", f), d.setAttribute(\"data-hc-time\", b), f = b);\n          d.value = e.dateFormat(this.inputTypeFormats[d.type] || c.inputEditDateFormat, f);\n          a && a.attr({\n            text: e.dateFormat(c.inputDateFormat, f)\n          });\n        }\n      };\n\n      e.prototype.setInputExtremes = function (a, b, e) {\n        if (a = \"min\" === a ? this.minInput : this.maxInput) {\n          var c = this.inputTypeFormats[a.type],\n              d = this.chart.time;\n          c && (b = d.dateFormat(c, b), a.min !== b && (a.min = b), e = d.dateFormat(c, e), a.max !== e && (a.max = e));\n        }\n      };\n\n      e.prototype.showInput = function (a) {\n        var c = \"min\" === a ? this.minDateBox : this.maxDateBox;\n\n        if ((a = \"min\" === a ? this.minInput : this.maxInput) && c && this.inputGroup) {\n          var b = \"text\" === a.type,\n              e = this.inputGroup,\n              f = e.translateX;\n          e = e.translateY;\n          var g = this.options.inputBoxWidth;\n          d(a, {\n            width: b ? c.width + (g ? -2 : 20) + \"px\" : \"auto\",\n            height: b ? c.height - 2 + \"px\" : \"auto\",\n            border: \"2px solid silver\"\n          });\n          b && g ? d(a, {\n            left: f + c.x + \"px\",\n            top: e + \"px\"\n          }) : d(a, {\n            left: Math.min(Math.round(c.x + f - (a.offsetWidth - c.width) / 2), this.chart.chartWidth - a.offsetWidth) + \"px\",\n            top: e - (a.offsetHeight - c.height) / 2 + \"px\"\n          });\n        }\n      };\n\n      e.prototype.hideInput = function (a) {\n        (a = \"min\" === a ? this.minInput : this.maxInput) && d(a, {\n          top: \"-9999em\",\n          border: 0,\n          width: \"1px\",\n          height: \"1px\"\n        });\n      };\n\n      e.prototype.defaultInputDateParser = function (a, b, e) {\n        var c = a.split(\"/\").join(\"-\").split(\" \").join(\"T\");\n        -1 === c.indexOf(\"T\") && (c += \"T00:00\");\n        if (b) c += \"Z\";else {\n          var d;\n          if (d = A.isSafari) d = c, d = !(6 < d.length && (d.lastIndexOf(\"-\") === d.length - 6 || d.lastIndexOf(\"+\") === d.length - 6));\n          d && (d = new Date(c).getTimezoneOffset() / 60, c += 0 >= d ? \"+\".concat(F(-d), \":00\") : \"-\".concat(F(d), \":00\"));\n        }\n        c = Date.parse(c);\n        q(c) || (a = a.split(\"-\"), c = Date.UTC(g(a[0]), g(a[1]) - 1, g(a[2])));\n        e && b && q(c) && (c += e.getTimezoneOffset(c));\n        return c;\n      };\n\n      e.prototype.drawInput = function (a) {\n        function b() {\n          var b = g.getInputValue(a),\n              e = c.xAxis[0],\n              d = c.scroller && c.scroller.xAxis ? c.scroller.xAxis : e,\n              h = d.dataMin;\n          d = d.dataMax;\n          var f = g.maxInput,\n              n = g.minInput;\n          b !== Number(v.getAttribute(\"data-hc-time-previous\")) && q(b) && (v.setAttribute(\"data-hc-time-previous\", b), r && f && q(h) ? b > Number(f.getAttribute(\"data-hc-time\")) ? b = void 0 : b < h && (b = h) : n && q(d) && (b < Number(n.getAttribute(\"data-hc-time\")) ? b = void 0 : b > d && (b = d)), \"undefined\" !== typeof b && e.setExtremes(r ? b : e.min, r ? e.max : b, void 0, void 0, {\n            trigger: \"rangeSelectorInput\"\n          }));\n        }\n\n        var c = this.chart,\n            e = this.div,\n            f = this.inputGroup,\n            g = this,\n            k = c.renderer.style || {},\n            l = c.renderer,\n            x = c.options.rangeSelector,\n            r = \"min\" === a,\n            z = t.lang[r ? \"rangeSelectorFrom\" : \"rangeSelectorTo\"] || \"\";\n        z = l.label(z, 0).addClass(\"highcharts-range-label\").attr({\n          padding: z ? 2 : 0,\n          height: z ? x.inputBoxHeight : 0\n        }).add(f);\n        l = l.label(\"\", 0).addClass(\"highcharts-range-input\").attr({\n          padding: 2,\n          width: x.inputBoxWidth,\n          height: x.inputBoxHeight,\n          \"text-align\": \"center\"\n        }).on(\"click\", function () {\n          g.showInput(a);\n          g[a + \"Input\"].focus();\n        });\n        c.styledMode || l.attr({\n          stroke: x.inputBoxBorderColor,\n          \"stroke-width\": 1\n        });\n        l.add(f);\n        var v = m(\"input\", {\n          name: a,\n          className: \"highcharts-range-selector\"\n        }, void 0, e);\n        v.setAttribute(\"type\", D(x.inputDateFormat || \"%b %e, %Y\"));\n        c.styledMode || (z.css(J(k, x.labelStyle)), l.css(J({\n          color: \"#333333\"\n        }, k, x.inputStyle)), d(v, E({\n          position: \"absolute\",\n          border: 0,\n          boxShadow: \"0 0 15px rgba(0,0,0,0.3)\",\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          textAlign: \"center\",\n          fontSize: k.fontSize,\n          fontFamily: k.fontFamily,\n          top: \"-9999em\"\n        }, x.inputStyle)));\n\n        v.onfocus = function () {\n          g.showInput(a);\n        };\n\n        v.onblur = function () {\n          v === A.doc.activeElement && b();\n          g.hideInput(a);\n          g.setInputValue(a);\n          v.blur();\n        };\n\n        var y = !1;\n\n        v.onchange = function () {\n          y || (b(), g.hideInput(a), v.blur());\n        };\n\n        v.onkeypress = function (a) {\n          13 === a.keyCode && b();\n        };\n\n        v.onkeydown = function (a) {\n          y = !0;\n          38 !== a.keyCode && 40 !== a.keyCode || b();\n        };\n\n        v.onkeyup = function () {\n          y = !1;\n        };\n\n        return {\n          dateBox: l,\n          input: v,\n          label: z\n        };\n      };\n\n      e.prototype.getPosition = function () {\n        var a = this.chart,\n            b = a.options.rangeSelector;\n        a = \"top\" === b.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;\n        return {\n          buttonTop: a + b.buttonPosition.y,\n          inputTop: a + b.inputPosition.y - 10\n        };\n      };\n\n      e.prototype.getYTDExtremes = function (a, b, e) {\n        var c = this.chart.time,\n            d = new c.Date(a),\n            f = c.get(\"FullYear\", d);\n        e = e ? c.Date.UTC(f, 0, 1) : +new c.Date(f, 0, 1);\n        b = Math.max(b, e);\n        d = d.getTime();\n        return {\n          max: Math.min(a || d, d),\n          min: b\n        };\n      };\n\n      e.prototype.render = function (a, b) {\n        var c = this.chart,\n            e = c.renderer,\n            d = c.container,\n            f = c.options,\n            g = f.rangeSelector,\n            p = M(f.chart.style && f.chart.style.zIndex, 0) + 1;\n        f = g.inputEnabled;\n\n        if (!1 !== g.enabled) {\n          this.rendered || (this.group = e.g(\"range-selector-group\").attr({\n            zIndex: 7\n          }).add(), this.div = m(\"div\", void 0, {\n            position: \"relative\",\n            height: 0,\n            zIndex: p\n          }), this.buttonOptions.length && this.renderButtons(), d.parentNode && d.parentNode.insertBefore(this.div, d), f && (this.inputGroup = e.g(\"input-group\").add(this.group), e = this.drawInput(\"min\"), this.minDateBox = e.dateBox, this.minLabel = e.label, this.minInput = e.input, e = this.drawInput(\"max\"), this.maxDateBox = e.dateBox, this.maxLabel = e.label, this.maxInput = e.input));\n\n          if (f && (this.setInputValue(\"min\", a), this.setInputValue(\"max\", b), a = c.scroller && c.scroller.getUnionExtremes() || c.xAxis[0] || {}, C(a.dataMin) && C(a.dataMax) && (c = c.xAxis[0].minRange || 0, this.setInputExtremes(\"min\", a.dataMin, Math.min(a.dataMax, this.getInputValue(\"max\")) - c), this.setInputExtremes(\"max\", Math.max(a.dataMin, this.getInputValue(\"min\")) + c, a.dataMax)), this.inputGroup)) {\n            var k = 0;\n            [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(function (a) {\n              if (a) {\n                var b = a.getBBox().width;\n                b && (a.attr({\n                  x: k\n                }), k += b + g.inputSpacing);\n              }\n            });\n          }\n\n          this.alignElements();\n          this.rendered = !0;\n        }\n      };\n\n      e.prototype.renderButtons = function () {\n        var a = this,\n            e = this.buttons,\n            d = this.options,\n            h = t.lang,\n            f = this.chart.renderer,\n            g = J(d.buttonTheme),\n            k = g && g.states,\n            l = g.width || 28;\n        delete g.width;\n        delete g.states;\n        this.buttonGroup = f.g(\"range-selector-buttons\").add(this.group);\n        var q = this.dropdown = m(\"select\", void 0, {\n          position: \"absolute\",\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          border: 0,\n          top: \"-9999em\",\n          cursor: \"pointer\",\n          opacity: .0001\n        }, this.div);\n        b(q, \"touchstart\", function () {\n          q.style.fontSize = \"16px\";\n        });\n        [[A.isMS ? \"mouseover\" : \"mouseenter\"], [A.isMS ? \"mouseout\" : \"mouseleave\"], [\"change\", \"click\"]].forEach(function (c) {\n          var d = c[0],\n              h = c[1];\n          b(q, d, function () {\n            var b = e[a.currentButtonIndex()];\n            b && H(b.element, h || d);\n          });\n        });\n        this.zoomText = f.label(h && h.rangeSelectorZoom || \"\", 0).attr({\n          padding: d.buttonTheme.padding,\n          height: d.buttonTheme.height,\n          paddingLeft: 0,\n          paddingRight: 0\n        }).add(this.buttonGroup);\n        this.chart.styledMode || (this.zoomText.css(d.labelStyle), g[\"stroke-width\"] = M(g[\"stroke-width\"], 0));\n        m(\"option\", {\n          textContent: this.zoomText.textStr,\n          disabled: !0\n        }, void 0, q);\n        this.buttonOptions.forEach(function (b, c) {\n          m(\"option\", {\n            textContent: b.title || b.text\n          }, void 0, q);\n          e[c] = f.button(b.text, 0, 0, function (e) {\n            var d = b.events && b.events.click,\n                h;\n            d && (h = d.call(b, e));\n            !1 !== h && a.clickButton(c);\n            a.isActive = !0;\n          }, g, k && k.hover, k && k.select, k && k.disabled).attr({\n            \"text-align\": \"center\",\n            width: l\n          }).add(a.buttonGroup);\n          b.title && e[c].attr(\"title\", b.title);\n        });\n      };\n\n      e.prototype.alignElements = function () {\n        var a = this,\n            b = this.buttonGroup,\n            e = this.buttons,\n            d = this.chart,\n            f = this.group,\n            g = this.inputGroup,\n            k = this.options,\n            l = this.zoomText,\n            m = d.options,\n            q = m.exporting && !1 !== m.exporting.enabled && m.navigation && m.navigation.buttonOptions;\n        m = k.buttonPosition;\n\n        var x = k.inputPosition,\n            t = k.verticalAlign,\n            r = function r(b, c) {\n          return q && a.titleCollision(d) && \"top\" === t && \"right\" === c.align && c.y - b.getBBox().height - 12 < (q.y || 0) + (q.height || 0) + d.spacing[0] ? -40 : 0;\n        },\n            v = d.plotLeft;\n\n        if (f && m && x) {\n          var y = m.x - d.spacing[3];\n\n          if (b) {\n            this.positionButtons();\n\n            if (!this.initialButtonGroupWidth) {\n              var I = 0;\n              l && (I += l.getBBox().width + 5);\n              e.forEach(function (a, b) {\n                I += a.width;\n                b !== e.length - 1 && (I += k.buttonSpacing);\n              });\n              this.initialButtonGroupWidth = I;\n            }\n\n            v -= d.spacing[3];\n            this.updateButtonStates();\n            l = r(b, m);\n            this.alignButtonGroup(l);\n            f.placed = b.placed = d.hasLoaded;\n          }\n\n          b = 0;\n          g && (b = r(g, x), \"left\" === x.align ? y = v : \"right\" === x.align && (y = -Math.max(d.axisOffset[1], -b)), g.align({\n            y: x.y,\n            width: g.getBBox().width,\n            align: x.align,\n            x: x.x + y - 2\n          }, !0, d.spacingBox), g.placed = d.hasLoaded);\n          this.handleCollision(b);\n          f.align({\n            verticalAlign: t\n          }, !0, d.spacingBox);\n          g = f.alignAttr.translateY;\n          b = f.getBBox().height + 20;\n          r = 0;\n          \"bottom\" === t && (r = (r = d.legend && d.legend.options) && \"bottom\" === r.verticalAlign && r.enabled && !r.floating ? d.legend.legendHeight + M(r.margin, 10) : 0, b = b + r - 20, r = g - b - (k.floating ? 0 : k.y) - (d.titleOffset ? d.titleOffset[2] : 0) - 10);\n          if (\"top\" === t) k.floating && (r = 0), d.titleOffset && d.titleOffset[0] && (r = d.titleOffset[0]), r += d.margin[0] - d.spacing[0] || 0;else if (\"middle\" === t) if (x.y === m.y) r = g;else if (x.y || m.y) r = 0 > x.y || 0 > m.y ? r - Math.min(x.y, m.y) : g - b;\n          f.translate(k.x, k.y + Math.floor(r));\n          m = this.minInput;\n          x = this.maxInput;\n          g = this.dropdown;\n          k.inputEnabled && m && x && (m.style.marginTop = f.translateY + \"px\", x.style.marginTop = f.translateY + \"px\");\n          g && (g.style.marginTop = f.translateY + \"px\");\n        }\n      };\n\n      e.prototype.alignButtonGroup = function (a, b) {\n        var c = this.chart,\n            e = this.buttonGroup,\n            d = this.options.buttonPosition,\n            f = c.plotLeft - c.spacing[3],\n            g = d.x - c.spacing[3];\n        \"right\" === d.align ? g += a - f : \"center\" === d.align && (g -= f / 2);\n        e && e.align({\n          y: d.y,\n          width: M(b, this.initialButtonGroupWidth),\n          align: d.align,\n          x: g\n        }, !0, c.spacingBox);\n      };\n\n      e.prototype.positionButtons = function () {\n        var a = this.buttons,\n            b = this.chart,\n            e = this.options,\n            d = this.zoomText,\n            f = b.hasLoaded ? \"animate\" : \"attr\",\n            g = e.buttonPosition,\n            k = b.plotLeft,\n            l = k;\n        d && \"hidden\" !== d.visibility && (d[f]({\n          x: M(k + g.x, k)\n        }), l += g.x + d.getBBox().width + 5);\n        this.buttonOptions.forEach(function (b, c) {\n          if (\"hidden\" !== a[c].visibility) a[c][f]({\n            x: l\n          }), l += a[c].width + e.buttonSpacing;else a[c][f]({\n            x: k\n          });\n        });\n      };\n\n      e.prototype.handleCollision = function (a) {\n        var b = this,\n            c = this.chart,\n            e = this.buttonGroup,\n            d = this.inputGroup,\n            f = this.options,\n            g = f.buttonPosition,\n            k = f.dropdown,\n            l = f.inputPosition;\n\n        f = function f() {\n          var a = 0;\n          b.buttons.forEach(function (b) {\n            b = b.getBBox();\n            b.width > a && (a = b.width);\n          });\n          return a;\n        };\n\n        var m = function m(b) {\n          if (d && e) {\n            var c = d.alignAttr.translateX + d.alignOptions.x - a + d.getBBox().x + 2,\n                f = d.alignOptions.width,\n                h = e.alignAttr.translateX + e.getBBox().x;\n            return h + b > c && c + f > h && g.y < l.y + d.getBBox().height;\n          }\n\n          return !1;\n        },\n            q = function q() {\n          d && e && d.attr({\n            translateX: d.alignAttr.translateX + (c.axisOffset[1] >= -a ? 0 : -a),\n            translateY: d.alignAttr.translateY + e.getBBox().height + 10\n          });\n        };\n\n        if (e) {\n          if (\"always\" === k) {\n            this.collapseButtons(a);\n            m(f()) && q();\n            return;\n          }\n\n          \"never\" === k && this.expandButtons();\n        }\n\n        d && e ? l.align === g.align || m(this.initialButtonGroupWidth + 20) ? \"responsive\" === k ? (this.collapseButtons(a), m(f()) && q()) : q() : \"responsive\" === k && this.expandButtons() : e && \"responsive\" === k && (this.initialButtonGroupWidth > c.plotWidth ? this.collapseButtons(a) : this.expandButtons());\n      };\n\n      e.prototype.collapseButtons = function (a) {\n        var b = this.buttons,\n            c = this.buttonOptions,\n            e = this.chart,\n            d = this.dropdown,\n            f = this.options,\n            g = this.zoomText,\n            k = e.userOptions.rangeSelector && e.userOptions.rangeSelector.buttonTheme || {},\n            l = function l(a) {\n          return {\n            text: a ? \"\" + a + \" \\u25BE\" : \"\\u25BE\",\n            width: \"auto\",\n            paddingLeft: M(f.buttonTheme.paddingLeft, k.padding, 8),\n            paddingRight: M(f.buttonTheme.paddingRight, k.padding, 8)\n          };\n        };\n\n        g && g.hide();\n        var m = !1;\n        c.forEach(function (a, c) {\n          c = b[c];\n          2 !== c.state ? c.hide() : (c.show(), c.attr(l(a.text)), m = !0);\n        });\n        m || (d && (d.selectedIndex = 0), b[0].show(), b[0].attr(l(this.zoomText && this.zoomText.textStr)));\n        c = f.buttonPosition.align;\n        this.positionButtons();\n        \"right\" !== c && \"center\" !== c || this.alignButtonGroup(a, b[this.currentButtonIndex()].getBBox().width);\n        this.showDropdown();\n      };\n\n      e.prototype.expandButtons = function () {\n        var a = this.buttons,\n            b = this.buttonOptions,\n            e = this.options,\n            d = this.zoomText;\n        this.hideDropdown();\n        d && d.show();\n        b.forEach(function (b, c) {\n          c = a[c];\n          c.show();\n          c.attr({\n            text: b.text,\n            width: e.buttonTheme.width || 28,\n            paddingLeft: M(e.buttonTheme.paddingLeft, \"unset\"),\n            paddingRight: M(e.buttonTheme.paddingRight, \"unset\")\n          });\n          2 > c.state && c.setState(0);\n        });\n        this.positionButtons();\n      };\n\n      e.prototype.currentButtonIndex = function () {\n        var a = this.dropdown;\n        return a && 0 < a.selectedIndex ? a.selectedIndex - 1 : 0;\n      };\n\n      e.prototype.showDropdown = function () {\n        var a = this.buttonGroup,\n            b = this.buttons,\n            e = this.chart,\n            f = this.dropdown;\n\n        if (a && f) {\n          var g = a.translateX;\n          a = a.translateY;\n          b = b[this.currentButtonIndex()].getBBox();\n          d(f, {\n            left: e.plotLeft + g + \"px\",\n            top: a + .5 + \"px\",\n            width: b.width + \"px\",\n            height: b.height + \"px\"\n          });\n          this.hasVisibleDropdown = !0;\n        }\n      };\n\n      e.prototype.hideDropdown = function () {\n        var a = this.dropdown;\n        a && (d(a, {\n          top: \"-9999em\",\n          width: \"1px\",\n          height: \"1px\"\n        }), this.hasVisibleDropdown = !1);\n      };\n\n      e.prototype.getHeight = function () {\n        var a = this.options,\n            b = this.group,\n            e = a.y,\n            d = a.buttonPosition.y,\n            f = a.inputPosition.y;\n        if (a.height) return a.height;\n        this.alignElements();\n        a = b ? b.getBBox(!0).height + 13 + e : 0;\n        b = Math.min(f, d);\n        if (0 > f && 0 > d || 0 < f && 0 < d) a += Math.abs(b);\n        return a;\n      };\n\n      e.prototype.titleCollision = function (a) {\n        return !(a.options.title.text || a.options.subtitle.text);\n      };\n\n      e.prototype.update = function (a) {\n        var b = this.chart;\n        J(!0, b.options.rangeSelector, a);\n        this.destroy();\n        this.init(b);\n        this.render();\n      };\n\n      e.prototype.destroy = function () {\n        var a = this,\n            b = a.minInput,\n            d = a.maxInput;\n        a.eventsToUnbind && (a.eventsToUnbind.forEach(function (a) {\n          return a();\n        }), a.eventsToUnbind = void 0);\n        k(a.buttons);\n        b && (b.onfocus = b.onblur = b.onchange = null);\n        d && (d.onfocus = d.onblur = d.onchange = null);\n        N(a, function (b, c) {\n          b && \"chart\" !== c && (b instanceof y ? b.destroy() : b instanceof window.HTMLElement && K(b));\n          b !== e.prototype[c] && (a[c] = null);\n        }, this);\n      };\n\n      return e;\n    }();\n\n    x.prototype.defaultButtons = [{\n      type: \"month\",\n      count: 1,\n      text: \"1m\",\n      title: \"View 1 month\"\n    }, {\n      type: \"month\",\n      count: 3,\n      text: \"3m\",\n      title: \"View 3 months\"\n    }, {\n      type: \"month\",\n      count: 6,\n      text: \"6m\",\n      title: \"View 6 months\"\n    }, {\n      type: \"ytd\",\n      text: \"YTD\",\n      title: \"View year to date\"\n    }, {\n      type: \"year\",\n      count: 1,\n      text: \"1y\",\n      title: \"View 1 year\"\n    }, {\n      type: \"all\",\n      text: \"All\",\n      title: \"View all\"\n    }];\n    x.prototype.inputTypeFormats = {\n      \"datetime-local\": \"%Y-%m-%dT%H:%M:%S\",\n      date: \"%Y-%m-%d\",\n      time: \"%H:%M:%S\"\n    };\n\n    a.prototype.minFromRange = function () {\n      var a = this.range,\n          b = a.type,\n          d = this.max,\n          f = this.chart.time,\n          g = function g(a, c) {\n        var e = \"year\" === b ? \"FullYear\" : \"Month\",\n            d = new f.Date(a),\n            g = f.get(e, d);\n        f.set(e, d, g + c);\n        g === f.get(e, d) && f.set(\"Date\", d, 0);\n        return d.getTime() - a;\n      };\n\n      if (q(a)) {\n        var k = d - a;\n        var l = a;\n      } else a && (k = d + g(d, -(a.count || 1)), this.chart && (this.chart.fixedRange = d - k));\n\n      var m = M(this.dataMin, Number.MIN_VALUE);\n      q(k) || (k = m);\n      k <= m && (k = m, \"undefined\" === typeof l && (l = g(k, a.count)), this.newMax = Math.min(k + l, M(this.dataMax, Number.MAX_VALUE)));\n      q(d) ? !q(a) && a && a._offsetMin && (k += a._offsetMin) : k = void 0;\n      return k;\n    };\n\n    if (!A.RangeSelector) {\n      var I = [],\n          f = function f(a) {\n        function c() {\n          d && (e = a.xAxis[0].getExtremes(), f = a.legend, k = d && d.options.verticalAlign, q(e.min) && d.render(e.min, e.max), f.display && \"top\" === k && k === f.options.verticalAlign && (g = J(a.spacingBox), g.y = \"vertical\" === f.options.layout ? a.plotTop : g.y + d.getHeight(), f.group.placed = !1, f.align(g)));\n        }\n\n        var e,\n            d = a.rangeSelector,\n            f,\n            g,\n            k;\n        d && (L(I, function (b) {\n          return b[0] === a;\n        }) || I.push([a, [b(a.xAxis[0], \"afterSetExtremes\", function (a) {\n          d && d.render(a.min, a.max);\n        }), b(a, \"redraw\", c)]]), c());\n      };\n\n      b(v, \"afterGetContainer\", function () {\n        this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new x(this));\n      });\n      b(v, \"beforeRender\", function () {\n        var a = this.axes,\n            b = this.rangeSelector;\n        b && (q(b.deferredYTDClick) && (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick), a.forEach(function (a) {\n          a.updateNames();\n          a.setScale();\n        }), this.getAxisMargins(), b.render(), a = b.options.verticalAlign, b.options.floating || (\"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0)));\n      });\n      b(v, \"update\", function (a) {\n        var b = a.options.rangeSelector;\n        a = this.rangeSelector;\n        var d = this.extraBottomMargin,\n            e = this.extraTopMargin;\n        b && b.enabled && !C(a) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = a = new x(this));\n        this.extraTopMargin = this.extraBottomMargin = !1;\n        a && (f(this), b = b && b.verticalAlign || a.options && a.options.verticalAlign, a.options.floating || (\"bottom\" === b ? this.extraBottomMargin = !0 : \"middle\" !== b && (this.extraTopMargin = !0)), this.extraBottomMargin !== d || this.extraTopMargin !== e) && (this.isDirtyBox = !0);\n      });\n      b(v, \"render\", function () {\n        var a = this.rangeSelector;\n        a && !a.options.floating && (a.render(), a = a.options.verticalAlign, \"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0));\n      });\n      b(v, \"getMargins\", function () {\n        var a = this.rangeSelector;\n        a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));\n      });\n      v.prototype.callbacks.push(f);\n      b(v, \"destroy\", function () {\n        for (var a = 0; a < I.length; a++) {\n          var b = I[a];\n\n          if (b[0] === this) {\n            b[1].forEach(function (a) {\n              return a();\n            });\n            I.splice(a, 1);\n            break;\n          }\n        }\n      });\n      A.RangeSelector = x;\n    }\n\n    return x;\n  });\n  J(a, \"Core/Chart/StockChart.js\", [a[\"Core/Animation/AnimationUtilities.js\"], a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/FormatUtilities.js\"], a[\"Core/DefaultOptions.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Renderer/SVG/SVGRenderer.js\"], a[\"Core/Utilities.js\"]], function (a, v, A, l, y, r, D, t) {\n    function b(a, b) {\n      return \"xAxis\" === a ? {\n        minPadding: 0,\n        maxPadding: 0,\n        overscroll: 0,\n        ordinal: !0,\n        title: {\n          text: null\n        },\n        labels: {\n          overflow: \"justify\"\n        },\n        showLastLabel: !0\n      } : \"yAxis\" === a ? {\n        labels: {\n          y: -2\n        },\n        opposite: F(b.opposite, !0),\n        showLastLabel: !(!b.categories && \"category\" !== b.type),\n        title: {\n          text: null\n        }\n      } : {};\n    }\n\n    function m(a, b) {\n      if (\"xAxis\" === a) {\n        a = k();\n        var d = {\n          type: \"datetime\",\n          categories: void 0\n        };\n        F(b.navigator && b.navigator.enabled, a.navigator.enabled, !0) && (d.startOnTick = !1, d.endOnTick = !1);\n        return d;\n      }\n\n      return {};\n    }\n\n    var d = this && this.__extends || function () {\n      var _a5 = function a(b, d) {\n        _a5 = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var d in b) {\n            b.hasOwnProperty(d) && (a[d] = b[d]);\n          }\n        };\n\n        return _a5(b, d);\n      };\n\n      return function (b, d) {\n        function g() {\n          this.constructor = b;\n        }\n\n        _a5(b, d);\n\n        b.prototype = null === d ? Object.create(d) : (g.prototype = d.prototype, new g());\n      };\n    }(),\n        C = l.format,\n        k = y.getOptions;\n\n    a = t.addEvent;\n    var K = t.clamp,\n        E = t.defined,\n        J = t.extend,\n        H = t.find,\n        q = t.isNumber,\n        R = t.isString,\n        N = t.merge,\n        F = t.pick,\n        M = t.splat;\n\n    t = function (a) {\n      function g() {\n        return null !== a && a.apply(this, arguments) || this;\n      }\n\n      d(g, a);\n\n      g.prototype.init = function (d, g) {\n        var f = k(),\n            e = d.xAxis,\n            c = d.yAxis,\n            l = F(d.navigator && d.navigator.enabled, f.navigator.enabled, !0);\n        d.xAxis = d.yAxis = void 0;\n        l = N({\n          chart: {\n            panning: {\n              enabled: !0,\n              type: \"x\"\n            },\n            zooming: {\n              pinchType: \"x\"\n            }\n          },\n          navigator: {\n            enabled: l\n          },\n          scrollbar: {\n            enabled: F(f.scrollbar && f.scrollbar.enabled, !0)\n          },\n          rangeSelector: {\n            enabled: F(f.rangeSelector.enabled, !0)\n          },\n          title: {\n            text: null\n          },\n          tooltip: {\n            split: F(f.tooltip.split, !0),\n            crosshairs: !0\n          },\n          legend: {\n            enabled: !1\n          }\n        }, d, {\n          isStock: !0\n        });\n        d.xAxis = e;\n        d.yAxis = c;\n        l.xAxis = M(d.xAxis || {}).map(function (a, c) {\n          return N(b(\"xAxis\", a), f.xAxis, f.xAxis && f.xAxis[c], a, m(\"xAxis\", d));\n        });\n        l.yAxis = M(d.yAxis || {}).map(function (a, c) {\n          return N(b(\"yAxis\", a), f.yAxis, f.yAxis && f.yAxis[c], a);\n        });\n        a.prototype.init.call(this, l, g);\n      };\n\n      g.prototype.createAxis = function (d, g) {\n        g.axis = N(b(d, g.axis), g.axis, m(d, this.userOptions));\n        return a.prototype.createAxis.call(this, d, g);\n      };\n\n      return g;\n    }(A);\n\n    (function (a) {\n      a.stockChart = function (b, d, g) {\n        return new a(b, d, g);\n      };\n    })(t || (t = {}));\n\n    a(r, \"setOptions\", function (a) {\n      var b;\n      this.chart.options.isStock && (this.is(\"column\") || this.is(\"columnrange\") ? b = {\n        borderWidth: 0,\n        shadow: !1\n      } : this.is(\"scatter\") || this.is(\"sma\") || (b = {\n        marker: {\n          enabled: !1,\n          radius: 2\n        }\n      }), b && (a.plotOptions[this.type] = N(a.plotOptions[this.type], b)));\n    });\n    a(v, \"autoLabelAlign\", function (a) {\n      var b = this.chart,\n          d = this.options;\n      b = b._labelPanes = b._labelPanes || {};\n      var g = this.options.labels;\n      this.chart.options.isStock && \"yAxis\" === this.coll && (d = d.top + \",\" + d.height, !b[d] && g.enabled && (15 === g.x && (g.x = 0), \"undefined\" === typeof g.align && (g.align = \"right\"), b[d] = this, a.align = \"right\", a.preventDefault()));\n    });\n    a(v, \"destroy\", function () {\n      var a = this.chart,\n          b = this.options && this.options.top + \",\" + this.options.height;\n      b && a._labelPanes && a._labelPanes[b] === this && delete a._labelPanes[b];\n    });\n    a(v, \"getPlotLinePath\", function (a) {\n      function b(a) {\n        var b = \"xAxis\" === a ? \"yAxis\" : \"xAxis\";\n        a = d.options[b];\n        return q(a) ? [f[b][a]] : R(a) ? [f.get(a)] : g.map(function (a) {\n          return a[b];\n        });\n      }\n\n      var d = this,\n          g = this.isLinked && !this.series ? this.linkedParent.series : this.series,\n          f = d.chart,\n          e = f.renderer,\n          c = d.left,\n          k = d.top,\n          l,\n          h,\n          m,\n          t,\n          r = [],\n          v = [],\n          y = a.translatedValue,\n          A = a.value,\n          z = a.force;\n\n      if (f.options.isStock && !1 !== a.acrossPanes && \"xAxis\" === d.coll || \"yAxis\" === d.coll) {\n        a.preventDefault();\n        v = b(d.coll);\n        var C = d.isXAxis ? f.yAxis : f.xAxis;\n        C.forEach(function (a) {\n          if (E(a.options.id) ? -1 === a.options.id.indexOf(\"navigator\") : 1) {\n            var b = a.isXAxis ? \"yAxis\" : \"xAxis\";\n            b = E(a.options[b]) ? f[b][a.options[b]] : f[b][0];\n            d === b && v.push(a);\n          }\n        });\n        var D = v.length ? [] : [d.isXAxis ? f.yAxis[0] : f.xAxis[0]];\n        v.forEach(function (a) {\n          -1 !== D.indexOf(a) || H(D, function (b) {\n            return b.pos === a.pos && b.len === a.len;\n          }) || D.push(a);\n        });\n        var J = F(y, d.translate(A, void 0, void 0, a.old));\n        q(J) && (d.horiz ? D.forEach(function (a) {\n          var b;\n          h = a.pos;\n          t = h + a.len;\n          l = m = Math.round(J + d.transB);\n          \"pass\" !== z && (l < c || l > c + d.width) && (z ? l = m = K(l, c, c + d.width) : b = !0);\n          b || r.push([\"M\", l, h], [\"L\", m, t]);\n        }) : D.forEach(function (a) {\n          var b;\n          l = a.pos;\n          m = l + a.len;\n          h = t = Math.round(k + d.height - J);\n          \"pass\" !== z && (h < k || h > k + d.height) && (z ? h = t = K(h, k, k + d.height) : b = !0);\n          b || r.push([\"M\", l, h], [\"L\", m, t]);\n        }));\n        a.path = 0 < r.length ? e.crispPolyLine(r, a.lineWidth || 1) : null;\n      }\n    });\n\n    D.prototype.crispPolyLine = function (a, b) {\n      for (var d = 0; d < a.length; d += 2) {\n        var g = a[d],\n            f = a[d + 1];\n        g[1] === f[1] && (g[1] = f[1] = Math.round(g[1]) - b % 2 / 2);\n        g[2] === f[2] && (g[2] = f[2] = Math.round(g[2]) + b % 2 / 2);\n      }\n\n      return a;\n    };\n\n    a(v, \"afterHideCrosshair\", function () {\n      this.crossLabel && (this.crossLabel = this.crossLabel.hide());\n    });\n    a(v, \"afterDrawCrosshair\", function (a) {\n      var b, d;\n\n      if (this.crosshair && this.crosshair.label && this.crosshair.label.enabled && this.cross && q(this.min) && q(this.max)) {\n        var g = this.chart,\n            f = this.logarithmic,\n            e = this.crosshair.label,\n            c = this.horiz,\n            k = this.opposite,\n            l = this.left,\n            h = this.top,\n            m = this.crossLabel,\n            t = e.format,\n            r = \"\",\n            v = \"inside\" === this.options.tickPosition,\n            y = !1 !== this.crosshair.snap,\n            A = 0,\n            z = a.e || this.cross && this.cross.e;\n        a = a.point;\n        var D = this.min,\n            E = this.max;\n        f && (D = f.lin2log(D), E = f.lin2log(E));\n        f = c ? \"center\" : k ? \"right\" === this.labelAlign ? \"right\" : \"left\" : \"left\" === this.labelAlign ? \"left\" : \"center\";\n        m || (m = this.crossLabel = g.renderer.label(\"\", 0, void 0, e.shape || \"callout\").addClass(\"highcharts-crosshair-label highcharts-color-\" + (a && a.series ? a.series.colorIndex : this.series[0] && this.series[0].colorIndex)).attr({\n          align: e.align || f,\n          padding: F(e.padding, 8),\n          r: F(e.borderRadius, 3),\n          zIndex: 2\n        }).add(this.labelGroup), g.styledMode || m.attr({\n          fill: e.backgroundColor || a && a.series && a.series.color || \"#666666\",\n          stroke: e.borderColor || \"\",\n          \"stroke-width\": e.borderWidth || 0\n        }).css(J({\n          color: \"#ffffff\",\n          fontWeight: \"normal\",\n          fontSize: \"11px\",\n          textAlign: \"center\"\n        }, e.style || {})));\n        c ? (f = y ? (a.plotX || 0) + l : z.chartX, h += k ? 0 : this.height) : (f = k ? this.width + l : 0, h = y ? (a.plotY || 0) + h : z.chartY);\n        t || e.formatter || (this.dateTime && (r = \"%b %d, %Y\"), t = \"{value\" + (r ? \":\" + r : \"\") + \"}\");\n        r = y ? this.isXAxis ? a.x : a.y : this.toValue(c ? z.chartX : z.chartY);\n        y = a && a.series ? a.series.isPointInside(a) : q(r) && r > D && r < E;\n        z = \"\";\n        t ? z = C(t, {\n          value: r\n        }, g) : e.formatter && q(r) && (z = e.formatter.call(this, r));\n        m.attr({\n          text: z,\n          x: f,\n          y: h,\n          visibility: y ? \"inherit\" : \"hidden\"\n        });\n        e = m.getBBox();\n        if (q(m.y)) if (c) {\n          if (v && !k || !v && k) h = m.y - e.height;\n        } else h = m.y - e.height / 2;\n        c ? (b = l - e.x, d = l + this.width - e.x) : (b = \"left\" === this.labelAlign ? l : 0, d = \"right\" === this.labelAlign ? l + this.width : g.chartWidth);\n        m.translateX < b && (A = b - m.translateX);\n        m.translateX + e.width >= d && (A = -(m.translateX + e.width - d));\n        m.attr({\n          x: f + A,\n          y: h,\n          anchorX: c ? f : this.opposite ? 0 : g.chartWidth,\n          anchorY: c ? this.opposite ? g.chartHeight : 0 : h + e.height / 2\n        });\n      }\n    });\n\n    r.prototype.forceCropping = function () {\n      var a = this.chart,\n          b = this.options.dataGrouping;\n      return !1 !== this.allowDG && b && F(b.enabled, a.options.isStock);\n    };\n\n    a(A, \"update\", function (a) {\n      a = a.options;\n      \"scrollbar\" in a && this.navigator && (N(!0, this.options.scrollbar, a.scrollbar), this.navigator.update({}, !1), delete a.scrollbar);\n    });\n    return t;\n  });\n  J(a, \"masters/modules/stock.src.js\", [a[\"Core/Globals.js\"], a[\"Core/Axis/OrdinalAxis.js\"], a[\"Series/DataModifyComposition.js\"], a[\"Core/Scrollbar.js\"], a[\"Core/Chart/StockChart.js\"]], function (a, v, A, l, y) {\n    a.Scrollbar = l;\n    a.StockChart = a.stockChart = y.stockChart;\n    l.compose(a.Axis);\n    v.compose(a.Axis, a.Series, a.Chart);\n    A.compose(a.Series, a.Axis, a.Point);\n  });\n});","map":null,"metadata":{},"sourceType":"script"}